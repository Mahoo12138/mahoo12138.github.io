<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>超乎你想象的Stm32中的TIM定时器</title>
      <link href="/stm32-6.html"/>
      <url>/stm32-6.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="定时器分类">定时器分类</h2><p>STM32F1 系列中，除了互联型的产品，共有 8 个定时器，分为基本定时器，通用定时器和高级定时器。</p><table><thead><tr><th>类别</th><th>定时器</th><th>分辨率</th><th>计数器类型</th><th>预分频系数</th><th>产生DMA</th><th>捕获/比较通道</th><th>互补输出</th></tr></thead><tbody><tr><td>高级定时器</td><td>TIM1，TIM8</td><td>16位</td><td>向上/向下</td><td>1~65535</td><td>可以</td><td>4</td><td>有</td></tr><tr><td>通用定时器</td><td>TIM2&lt;sub&gt;TIM5</td><td>16位</td><td>向上/向下</td><td>165535</td><td>可以</td><td>4</td><td>无</td></tr><tr><td>基本定时器</td><td>TIM6，TIM7</td><td>16位</td><td>向上</td><td>1~65535</td><td>可以</td><td>0</td><td>无</td></tr></tbody></table><h2 id="基本定时器框图">基本定时器框图</h2><img src="/stm32-6/Pictures\Blog\hexo_images\Study\STM32\tim1.png" style="zoom: 67%;"><ol><li><p><strong>时钟源</strong>TIMxCLK由APB1预分频提供，库函数中 APB1 预分频系数为 2 ，定时器时钟TIMxCLK = 36 * 2 =72</p></li><li><p><strong>计数器时钟</strong>CK_CNT 经 PSC 得到，PSC是16位预分频器，可对 TIMxCLK 进行1~65536 之间任意一个数进行分频：CK_INT=TIMxCLK/(PSC + 1)</p></li><li><p><strong>计数器</strong>CNT 是一个16位的计数器，只能向上计数，最大值位65535，计数值到达自动重装载寄存器时，产生更新时间，清零重新计数</p></li><li><p><strong>自动重装载寄存器</strong>ARR 是一个16位计数器，存放最大计数值，到达此值，如果开启中断，则定时器产生中断</p></li></ol><h3 id="定时时间计算">定时时间计算</h3><p>定时器的定时时间等于计数器的中断周期乘以中断的次数。这里用定时 500ms 作为例子：</p><ul><li>设置PSC预分频器为 72 - 1 = 71 MHz，则定时器频率为 72M/(PSC + 1) = 1 MHz</li><li>设置 ARR = 1000 - 1，0 ~ 999，计数1000次</li><li>中断周期 T = 1000 * 1 / 1000000 = 1 ms，（1MHz 周期为 1 ns）</li></ul><h2 id="定时器初始化结构体">定时器初始化结构体</h2><p>基本定时器只用到<code>TIM_TimeBaseInitTypeDef</code>结构体：</p><pre class=" language-language-c"><code class="language-language-c">typedef struct {    uint16_t TIM_Prescaler; // 预分频器    uint16_t TIM_CounterMode; // 计数模式    uint32_t TIM_Period; // 定时器周期    uint16_t TIM_ClockDivision; // 时钟分频    uint8_t TIM_RepetitionCounter; // 重复计算器} TIM_TimeBaseInitTypeDef;</code></pre><p>而且只用到两个成员<mark>TIM_Prescaler</mark>和<mark>TIM_Period</mark>，也就是定时器分配器设置和定时器周期（自动重装载寄存器值）。aDAD</p><p>$\sum+ \pi + 2+1$</p><p>为什么啊?<br>$$<br>\Large {\sum^n_{i=1}} i+2<br>$$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单入门CSS预处理器Less和Sass</title>
      <link href="/pre-css.html"/>
      <url>/pre-css.html</url>
      
        <content type="html"><![CDATA[<p>Sass和Less都属于CSS预处理器，CSS预处理器定义了一种新的语言，其基本的思想是，用一种特殊的语言，为CSS增加一些编程的特性，如变量、语句，函数、继承等概念。将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编码开发工作。目前比较流行的有<a href="https://sass-lang.com/" target="_blank" rel="noopener"><strong>Sass</strong></a>、<a href="http://lesscss.org/" target="_blank" rel="noopener"><strong>less</strong></a>和<strong>stylus</strong>，我主要学习前两种。</p><h2 id="注释">注释</h2><p>在 less 和 Sass 中，单行的注释是不会被编译到 CSS 文件中的；</p><p>只有多行注释，也就是 CSS 中原本的代码注释，才会被编译生成到 CSS 文件中。</p><h2 id="变量，插值，作用域">变量，插值，作用域</h2><p>在 less 使用<code>@</code>定义变量，而在 Sass 中则使用<code>$</code>定义变量；</p><p>当把属性作为变量时，这也就是插值。插值的操作与定义变量略有不同，只是在引用变量时需要加上<code>@</code>和<code>{}</code>，而且选择器中也可以使用插值；Sass 中，使用<code>#</code>和<code>{}</code>完成插值操作，不过带上了变量前的<code>$</code>；</p><p>作用域很好理解，就像 Javascript 的那种变量的就近查找原则，也就是在<code>.box1</code>中的<strong>width</strong>和<strong>height</strong>属性的值都为<strong>200px</strong>，会优先在选择器内查找变量；Sass 唯一的不同之处在于<code>width:100px</code>而<code>height:200px</code>，这个顺序有差别。</p><pre class=" language-language-less"><code class="language-language-less">@number: 100px;@key: height;@i: 2;.box1{    // 作用域    width: @number;    @number: 200px;    @{key}: @number;}.box@{i}{    }</code></pre><pre class=" language-language-scss"><code class="language-language-scss">$number: 100px;$key: height;.box1{    width: $number;    $number: 200px;    #{$key}: $number;}</code></pre><h2 id="选择器嵌套，伪类嵌套，属性嵌套-Sass">选择器嵌套，伪类嵌套，属性嵌套(Sass)</h2><p><strong>选择器嵌套</strong>在CSS预编译中很常见，因为在编写带有很多子元素且一级一级嵌套的元素的样式时，往往需要很多选择器，在一级一级选择时，选择器不可避免会重复编写，而选择器的嵌套则可以一次性编写，但是编译产生的 css 还是css的语法，这样提高开发效率；在 Sass 中是完全一样的</p><pre class=" language-language-less"><code class="language-language-less">// less 代码ul{    list-style: none;    li{        float: left;        div{            margin: 10px;        }        p{            font-size: 16px;        }    }}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的css */ul {  list-style: none;}ul li {  float: left;}ul li div {  margin: 10px;}ul li p {  font-size: 16px;}</code></pre><p><strong>伪类嵌套</strong>也就是在选择器内部编写其伪类的样式，只需要在伪类前添加<code>&amp;</code>即可，Sass 也是完全一样的：</p><pre class=" language-language-less"><code class="language-language-less">div{    &:hover{        color: red;    }    img{}}</code></pre><p><strong>属性嵌套</strong>是在编写一些围绕某种属性的样式时，可以嵌套，在 Less 中不支持，具体可以看代码：</p><pre class=" language-language-scss"><code class="language-language-scss">// scss 文件div{    font: {        size: 16px;        weight: bold;        family: 微软雅黑;    }}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的css */@charset "UTF-8";div {  font-size: 16px;  font-weight: bold;  font-family: 微软雅黑;}</code></pre><p>注意<code>:</code>后的空格不能少，否则会编译错误</p><h2 id="运算，单位，转义，颜色">运算，单位，转义，颜色</h2><p>在变量使用时，可以对其做需要的运算，而涉及到不同的单位的量运算时，会以第一个变量为基准进行转化，而转义则是将某个代码段不经过编译直接输出到 CSS 中，颜色的RGB值也是可以进行运算的；</p><pre class=" language-language-less"><code class="language-language-less">// less 文件@num: 100px;.box2{    width: @num * 3;    height: @num + 10em;    margin: 10em + @num;    padding: 20px / 2;    padding: ~"20px / 2";    color: #101010 * 2;}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的css */.box2 {  width: 300px;  height: 110px;  margin: 110em;  padding: 10px;  padding: 20px / 2;  color: #202020;}</code></pre><p>在 Sass 中单位不同，是不能进行运算的，而且默认<code>/</code>是分割的操作不进行运算，如果需要做运算需要用<code>()</code>做转义；</p><pre class=" language-language-scss"><code class="language-language-scss">// scss 文件$num: 100px;.box2{    width: $num * 3;    // height: $num + 10em;    padding: 20px / 2;    padding: (20px / 2);    color: #010101 * 3;}</code></pre><h2 id="内置和自定义函数">内置和自定义函数</h2><pre class=" language-language-less"><code class="language-language-less">// less 和 Sass 文件.box {    width: round(3.5px);    height: percentage(0.2);}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的css */.box {    width: 4px;    height: 20%;}</code></pre><p>对于 Less 和 Sass 中的内置函数，并不是完全通用，可以在官方的API文档查询所需函数。</p><hr><p>在 Sass 中还可以自定义函数，使用参考一下代码：</p><pre class=" language-language-scss"><code class="language-language-scss">@function sum($n, $m){    @return $n + $m}.box {    width: sum(2px + 3px);}</code></pre><h2 id="混入，命名空间，继承">混入，命名空间，继承</h2><p>当编写一个样式时，可以像函数一样在另一个样式中引入，称为混入，当样式选择器添加了<code>()</code>，如==.hide()==，则其原本的样式不会在编译后的 css 文件中复现，而且当添加了括号时，还可以进行传参操作：</p><pre class=" language-language-less"><code class="language-language-less">// less 文件.show {    display: block;}.hide(@color) {    display: none;    color: @color;}.box {    width: 100px;    .show;    .hide(red);}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的 css */.show {    display: block;}.box {    width: 100px;    display: block;    display: none;    color: red;}</code></pre><p>在 Sass 中并不是类似选择器的方式编写混入，而是使用关键词<code>mixin</code>标记混入的样式，用<code>include</code>引入混入样式，同样的可以添加<code>()</code>进行传参：</p><pre class=" language-language-scss"><code class="language-language-scss">// scss 文件@mixin show {    display: bolck;}@mixin hide($color) {display: none;    color: red;}.box {    width: 100px;    @include show;    @include hide(red);}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的 css */.box {    width: 100px;    display: block;    display: none;    color: red;}</code></pre><hr><p>Less 中的命名空间是针对混入的一个扩展，上述代码中的混入都是在全局中定义的，而命名空间的引入，可以定义多个混入，可以更灵活的开发：</p><pre class=" language-language-less"><code class="language-language-less">#name(){    .show {        display: inline-block;        width: 100px;    }}.box {    #name.show;}</code></pre><hr><p>继承跟混入形式和功能上都很相像，不过会更精简代码：</p><pre class=" language-language-less"><code class="language-language-less">// less 文件.both {    display: block;}.box1{    &:extend(.both);}.box2{    &:extend(.both);}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的 css */.both,.box1,.box2{    display: block;}</code></pre><hr><pre class=" language-language-scss"><code class="language-language-scss">// scss 文件.both {    display: block;}.box1{    @extend .both;}.box2{    @extend .both;}</code></pre><p>在 Scss 中大致类似的用法，不过可以将<code>.both</code>改成<code>%both</code>，这样 both 样式就不会在 css 文件中编译生成了。</p><h2 id="合并，媒体查询">合并，媒体查询</h2><pre class=" language-language-less"><code class="language-language-less">// less 文件.box {    background+: url(a.png);     background+: url(b.png); transform+_: scale(2);    transform+_: rotate(30deg);}</code></pre><pre class=" language-language-scss"><code class="language-language-scss">// scss 文件$background: {    a: url(a.png),    b: url(b.png)};$transform: {    a: scale(2),    b: roate(30deg)};.box {background: map-values($background);    transform: zip(map-values($transform)...); }</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的 css */.box {background: url(a.png), url(b.png);    transform: scale(2) rotate(30reg);}</code></pre><hr><pre class=" language-language-less"><code class="language-language-less">// less & scss 文件.box {    width: 200px;    @media all and (min-width: 768px){        width: 600px;    }    @media all and (min-width: 1440px){        width: 900px;    }}</code></pre><pre class=" language-language-css"><code class="language-language-css">/* 编译生成的 css */.box {width: 200px;}@media all and (min-width: 768px){    .box{        width: 600px;    }}@media all and (min-width: 1440px){    .box {        width: 900px;    }}</code></pre><h2 id="条件，导入，循环">条件，导入，循环</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Less </tag>
            
            <tag> Sass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言再学习之基础语法</title>
      <link href="/c-c-5.html"/>
      <url>/c-c-5.html</url>
      
        <content type="html"><![CDATA[<h3 id="内联函数-——-C-中关键字-inline">内联函数 —— C 中关键字 inline</h3><p>调用函数时，一般会由于建立调用、传递参数、跳转到函数代码并返回等花费掉一些时间，而且一些函数被频繁调用，不断地有函数入栈，即<strong>函数栈</strong>，会造成栈空间或<strong>栈内存</strong>的大量消耗。</p><p>为了解决这个问题，在C99中特别地引入了<strong>inline修饰符</strong>，即内联函数。</p><p>关键字 inline 告诉编译器，任何地方只要调用内联函数，就直接把该函数的机器码插入到调用它的地方，类似于带参宏。</p><pre class=" language-language-c"><code class="language-language-c">inline int max (int a, int b){    if (a > b)        return a;    else        return b;}a = max (x, y); // 等价于 "a = (x > y ? x : y);"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用FSMC模拟8080时序控制LCD</title>
      <link href="/stm32-5.html"/>
      <url>/stm32-5.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="ILI9341-液晶控制器">ILI9341 液晶控制器</h2><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/ili9341.png" alt="ILI9341控制器内部框图"></p><p>ILI9341 控制器内部电路连接完后，其余信号线引出到排针</p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/lcd.png" alt="液晶屏引出的信号线" style="zoom:67%;"><h3 id="液晶屏引出的信号线说明">液晶屏引出的信号线说明</h3><table><thead><tr><th style="text-align:center">信号线</th><th style="text-align:center">ILI9341 对 应 的信号线</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">LCD_DB[15:0]</td><td style="text-align:center">D[15:0]</td><td style="text-align:left">数据信号</td></tr><tr><td style="text-align:center">LCD_RD</td><td style="text-align:center">RDX</td><td style="text-align:left">读数据信号，低电平有效 ，</td></tr><tr><td style="text-align:center">LCD_RS</td><td style="text-align:center">D/CX</td><td style="text-align:left">数据/命令信号，高电平时， D[15:0]表示的是数据(RGB 像素数据或命令数据)；低电平时，D[15:0]表示控制命令</td></tr><tr><td style="text-align:center">LCD_RESET</td><td style="text-align:center">RESX</td><td style="text-align:left">复位信号，低电平有效</td></tr><tr><td style="text-align:center">LCD_WR</td><td style="text-align:center">WRX</td><td style="text-align:left">写数据信号，低电平有效</td></tr><tr><td style="text-align:center">LCD_CS</td><td style="text-align:center">CSX</td><td style="text-align:left">片选信号，低电平有效</td></tr><tr><td style="text-align:center">LCD_BK</td><td style="text-align:center">-</td><td style="text-align:left">背光信号，低电平点亮</td></tr><tr><td style="text-align:center">GPIO[5:1]</td><td style="text-align:center">-</td><td style="text-align:left">触摸屏的控制信号线，下一章再介绍</td></tr></tbody></table><h2 id="FSMC简介">FSMC简介</h2><p>STM32F1 系列芯片使用 FSMC 外设来管理扩展的存储器， FSMC 是 Flexible Static<br>Memory Controller 的缩写，译为灵活的静态存储控制器。它可以用于驱动包括 SRAM、<br>NOR FLASH 以及 NAND FLSAH 类型的存储器，不能驱动如 SDRAM 这种动态的存储器而<br>在 STM32F429 系列的控制器中，它具有 FMC 外设，支持控制 SDRAM 存储器。</p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/fsmc.png" style="zoom:80%;"><p>MCU 对液晶屏的操作实际上就是把显示数据写入到显存中，与控制存储器非常类似，且8080 接口的通讯时序完全可以使用 FSMC 外设产生。</p><h3 id="模拟-8080-接口时序">模拟 8080 接口时序</h3><p>在模拟控制 LCD 时，是使用 FSMC 的 NOR\PSRAM 模式的， 而且使用的是类似异步、 地址与数据线独立的  NOR FLASH 类型的模式 B，实际上 CLK、 NWAIT、 NADV 引脚并没有使用到。</p><table><thead><tr><th style="text-align:center">FSMC 信 号 名</th><th style="text-align:center">信号方向</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">CLK</td><td style="text-align:center">输出</td><td>时钟（同步突发模式使用）</td></tr><tr><td style="text-align:center">A[25:0]</td><td style="text-align:center">输出</td><td>地址总线</td></tr><tr><td style="text-align:center">D[15:0]</td><td style="text-align:center">输入/输出</td><td>双向数据总线</td></tr><tr><td style="text-align:center">NE[x]</td><td style="text-align:center">输出</td><td>片选， x = 1…4</td></tr><tr><td style="text-align:center">NOE</td><td style="text-align:center">输出</td><td>输出使能</td></tr><tr><td style="text-align:center">NWE</td><td style="text-align:center">输出</td><td>写使能</td></tr><tr><td style="text-align:center">NWAIT</td><td style="text-align:center">输入</td><td>NOR 闪存要求 FSMC 等待的信号</td></tr><tr><td style="text-align:center">NADV</td><td style="text-align:center">输出</td><td>地址、数据线复用时作锁存信号</td></tr></tbody></table><p>对比 FSMC NOR/PSRAM 中的模式 B 时序与 ILI9341 液晶控制器芯片使用的 8080 时序可发现，这两个时序是十分相似的(除了 FSMC 的地址线 A 和 8080 的 D/CX 线，可以说是完全一样)</p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/8080vsnorflash.png" alt="FSMC模式B时序与8080时序对比（写过程）" style="zoom:80%;"><table><thead><tr><th>FSMC-NOR信号线</th><th>功能</th><th>8080 信号线</th><th>功能</th></tr></thead><tbody><tr><td>NEx</td><td>片选信号</td><td>CSX</td><td>片选信号</td></tr><tr><td>NWR</td><td>写使能</td><td>WRX</td><td>写使能</td></tr><tr><td>NOE  D[15:0]</td><td>读使能  数据信号</td><td>RDX  D[15:0]</td><td>读使能 数据信号</td></tr><tr><td>A[25:0]</td><td>地址信号</td><td>D/CX</td><td>数据/命令选择</td></tr></tbody></table><p>为了模拟出 8080 时序，我们可以把 FSMC 的 A0 地址线(也可以使用其它 A1/A2 等地<br>址线)与 ILI9341 芯片 8080 接口的 D/CX 信号线连接，那么当 A0 为高电平时(即 D/CX 为高<br>电平)，数据线 D[15:0]的信号会被 ILI9341 理解为数值，若 A0 为低电平时(即 D/CX 为低电<br>平)，传输的信号则会被理解为命令。</p><h3 id="FSMC的地址映射">FSMC的地址映射</h3><p>使用 FSMC 外接存储器时，其存储单元是映射到 STM32 的内部寻址空间的，这里也涉及到使用地址线某个引脚时，需要计算对应的地址，以达到控制输出高低电平。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/fsmc_addr.png" alt="FSMC 的地址映射"></p><h2 id="代码分析">代码分析</h2><h3 id="液晶LCD硬件相关宏定义">液晶LCD硬件相关宏定义</h3><p>根据液晶屏的原理图，将FSMC 控制液晶屏硬件相关的配置都以宏的形式定义：</p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/lcd_pin.png" alt="开发板与屏幕的连接" style="zoom:67%;"><pre class=" language-language-c"><code class="language-language-c">/*****************LCD控制信号******************///片选引脚#defineILI9341_CS_CLKRCC_APB2Periph_GPIOD#define ILI9341_CS_PORT GPIOD#define ILI9341_CS_PIN GPIO_Pin_7//数据命令引脚#defineILI9341_DC_CLKRCC_APB2Periph_GPIOD#defineILI9341_DC_PORTGPIOD#defineILI9341_DC_PINGPIO_Pin_11/****************数据信号线*****************/#define ILI9341_D0_CLK RCC_APB2Periph_GPIOD#define ILI9341_D0_PORT GPIOD#define ILI9341_D0_PIN GPIO_Pin_14//其他引脚省略</code></pre><h3 id="初始化-FSMC-的-GPIO">初始化 FSMC 的 GPIO</h3><p>利用上面的宏，编写 FSMC 的 GPIO 引脚初始化函数，对于 FSMC 引脚，全部直接初始化为复用推挽输出模式即可，而背光 BK 引脚及液晶复信 RST 信号则被初始化成普通的推挽输出模式，这两个液晶控制信号直接输出普通的电平控制即可。</p><pre class=" language-language-c"><code class="language-language-c">static void ILI9341_GPIO_Config (void){GPIO_InitTypeDef GPIO_InitStructure;    /* 使能 FSMC 对应相应管脚时钟*/    RCC_APB2PeriphClockCmd (    /* 控制信号 */    ILI9341_CS_CLK|ILI9341_DC_CLK|ILI9341_WR_CLK|    ILI9341_RD_CLK |ILI9341_BK_CLK|ILI9341_RST_CLK|    /* 数据信号 */    ILI9341_D0_CLK|ILI9341_D1_CLK, ENABLE);    /* 省略部分信号线 */    /* 配置 FSMC 相对应的数据线,FSMC-D0~D15 */    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    GPIO_InitStructure.GPIO_Pin = ILI9341_D0_PIN;        GPIO_Init(ILI9341_D0_PORT, &GPIO_InitStructure);/* 省略部分信号线 */    //设置复用推挽输出 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     GPIO_InitStructure.GPIO_Pin = ILI9341_RD_PIN; GPIO_Init (ILI9341_RD_PORT, &GPIO_InitStructure);/* 省略WR, CS, DC 控制引脚 */        //设置普通推挽输出    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    /* 配置 LCD 复位 RST 控制管脚 */ GPIO_InitStructure.GPIO_Pin = ILI9341_RST_PIN; GPIO_Init (ILI9341_RST_PORT, &GPIO_InitStructure);    /* 配置 LCD 背光控制管脚 BK */    GPIO_InitStructure.GPIO_Pin = ILI9341_BK_PIN; GPIO_Init (ILI9341_BK_PORT, &GPIO_InitStructure);}</code></pre><h3 id="配置-FSMC-的模式">配置 FSMC 的模式</h3><pre class=" language-language-c"><code class="language-language-c">static void ILI9341_FSMC_Config (void){    /* FSMC模式初始化结构体 */FSMC_NORSRAMInitTypeDef FSMC_NORSRAMInitStructure;    /* 读写时序结构体 */ FSMC_NORSRAMTimingInitTypeDef readWriteTiming;  /* 使能 FSMC 时钟*/ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);  //地址建立时间（ADDSET）为 1 个 HCLK 2/72M=28ns readWriteTiming.FSMC_AddressSetupTime = 0x01; //地址建立时间 //数据保持时间（DATAST） + 1 个 HCLK = 5/72M=70ns    readWriteTiming.FSMC_DataSetupTime = 0x04; //数据建立时间 //选择控制的模式 //模式 B, 异步 NOR FLASH 模式，与 ILI9341 的 8080 时序匹配 readWriteTiming.FSMC_AccessMode = FSMC_AccessMode_B;  /* 以下配置与模式 B 无关 */ readWriteTiming.FSMC_AddressHoldTime = 0x00; //地址保持时间，模式 B未用到 //设置总线转换周期，仅用于复用模式的 NOR 操作 readWriteTiming.FSMC_BusTurnAroundDuration = 0x00;  //设置时钟分频，仅用于同步类型的存储器 readWriteTiming.FSMC_CLKDivision = 0x00; //数据保持时间，仅用于同步型的 NOR readWriteTiming.FSMC_DataLatency = 0x00;        //选择使用的bank, 本次实例中使用的是FSMC_NE1    //需要在宏定义中定义：#define FSMC_Bank1_NORSRAMx FSMC_Bank1_NORSRAM1    FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAMx;    //设置地址总线是否与数据总线是否复用，仅用于NOR FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;    //设置要控制的存储器类型：本实例使用的是异步NOR FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_NOR;    /* 设置存储器的数据宽度 */ FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;    /* 设置是否支持突发访问模式，只支持同步类型的存储器 */ FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;    /* 设置等待信号的极性，仅用于同步类型存储器 */ FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;    /* 设置是否支持对齐的突发模式，仅用于同步 */ FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;    /* 配置等待信号（插入时间）在等待前有效还是等待期间有效，仅用于同步 */ FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;    /* 设置是否写使能 */ FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;        /* 设置是否使能等待状态插入，用于设置当存储器处于突发传输模式时，     * 是否允许通过 NWAIT 信号插入等待状态，不使用      */ FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;    /* 设置是否使能扩展模式，不使用，读写同一时序*/ FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;    /* 设置是否使能写突发操作 */ FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;    /* 当不使用扩展模式时，本参数用于配置读写时序，否则用于配置读时序 */ FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &readWriteTiming;    /* 当使用扩展模式时，本参数用于配置写时序 */FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &readWriteTiming; //初始化FSMC的配置 FSMC_NORSRAMInit (&FSMC_NORSRAMInitStructure); /* 使能 FSMC_Bank1_NORSRAMx */ FSMC_NORSRAMCmd (FSMC_Bank1_NORSRAMx, ENABLE);}</code></pre><h3 id="计算控制液晶屏时使用的地址">计算控制液晶屏时使用的地址</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/lie.png" alt=""></p><ul><li><p>首先确定板子NEx引脚的连接，本次实例使用的是<code>FSMC_NE1</code></p></li><li><p>在 数据手册 --&gt; 存储器映像 中查询<code>FSMC_bnak1 NOR/PSRAM 1</code>的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/fsmc_bank1_nor_addr.png" alt=""></p></li><li><p>使用的是<code>FSMS_NE1</code>也就是当访问到<code>0x6000000-0x63FFFFFF</code>这个地址范围内时，FSMC都会产生有效的访问时序；本实例中使用的是<code>FSMC_A16</code>地址线作为命令/数据选择线，即：</p><ul><li><p>使<code>FSMC_A16</code>为高电平，即第十六位为 1 ，可用地址范围内任意地址做一下运算：</p><pre class=" language-language-c"><code class="language-language-c">0X6000 0000 |= (1<<16) = 0x6001 0000;</code></pre></li><li><p>同样的，使<code>FSMC_A16</code>为低电平，即：</p><pre class=" language-language-c"><code class="language-language-c">0X6000 0000 &= ~ (1<<16) = 0x6000 0000;</code></pre></li></ul></li><li><p>由于地址线转换的问题，这里不细说，需要知道的是，STM32 内部的 HADDR 与 FSMC 的连接关系会左移一位，计算关系也会改变：</p><ul><li><p>使<code>FSMC_A16</code>地址线为高电平：</p><pre class=" language-language-c"><code class="language-language-c">0X6000 0000 |= (1<<(16+1)) = 0x6002 0000;</code></pre></li><li><p>使<code>FSMC_A16</code>地址线为低电平：</p><pre class=" language-language-c"><code class="language-language-c">0X6000 0000 &= ~(1<<(16+1)) = 0x6000 0000;</code></pre></li></ul></li></ul><h5 id="封装函数">封装函数</h5><p>因为在实例后面会频繁对LCD进行操作，所以把发送命令及发送数据的操作封装成了内联函数，会更方便调用：</p><pre class=" language-language-c"><code class="language-language-c">/*********** 定义 FSMC 参数宏 **********///FSMC_Bank1_NORSRAM 用于 LCD 命令操作的地址#define FSMC_Addr_ILI9341_CMD ( ( uint32_t ) 0x60020000 )//FSMC_Bank1_NORSRAM 用于 LCD 数据操作的地址#define FSMC_Addr_ILI9341_DATA ( ( uint32_t ) 0x60000000 )</code></pre><pre class=" language-language-c"><code class="language-language-c">//发送数据__inline void ILI9341_Write_Cmd (uint16_t usCmd){    (__IO uint16_t *)(FSMC_Addr_ILI9341_CMD) = usCmd;}//写入数据__inline void ILI9341_Write_Data (uint16_t usData){(__IO uint16_t *)(FSMC_Addr_ILI9341_DATA) = usData;}</code></pre><p>需要写操作时，只要把要发送的命令代码或数据作为参数输入到函数然后调用即可，对于液晶屏的读操作，把向指针赋值的过程改为读取指针内容即可。</p><pre class=" language-language-c"><code class="language-language-c">//读取数据__inline uint16_t ILI9341_Read_Data (void){return (*FSMC_Addr_ILI9341_DATA);}</code></pre><h4 id="检验封装">检验封装</h4><p>在上述函数封装好之后，进行一些测试检验使很有必要，我们可以查询<code>ILI9341</code>的数据文档，选择合适的命令进行测试：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/ili9341_0ch.png" alt=""></p><p>当发送命令<code>0x0C</code>，第二个参数会返回 LCD 的像素信息，可以封装一个检验函数如下：</p><pre class=" language-language-c"><code class="language-language-c">uint16_t Read_Pixel_Format(void){    ILI9341_Write_Cmd(0x0C);//发送命令参数    ILI9341_Read_Data();//读取第一个返回参数    return ILI9341_Read_Data();//返回第二个读取参数}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的网页梦 —— 前端基础 &amp; Vuejs</title>
      <link href="/vuejs.html"/>
      <url>/vuejs.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>自从上学期期末考试以后，就没有更新博客了，那时候是因为，你懂的嘛；</p><p>回到家后，肯定是玩啦，这么长的假期，同学聚会也少不了，过年期间更是忙的没话说，况且，今年的春节被这个新型冠状病毒整的是你死我活的，国家都进入一种战时状态，天佑中华吧，早点过去这次的考验。</p><p>相比于在医院战场上的医务工作者人员，住在荒野乡间的我，整个世界都闲了下来，但是，你说这可能吗？</p><p>在这个这么长的假期，我丝毫没有忘记我一直以来对网站的追求，从最初的用别人的完整的源码，到用别人的框架和主题，我都一直想自己亲手敲出属于自己的网站，于是我早就开始了……</p><h3 id="前端基础-HTML-CSS">前端基础 HTML &amp; CSS</h3><p>说到 HTML  &amp; CSS 经常接触网站的我，早有入门，但是没有经过系统化的学习了解，很多东西尚未知悉，我花了大约一周时间把尚硅谷推出的<a href="https://www.bilibili.com/video/av77217003" target="_blank" rel="noopener">培训课程</a>过了一遍，当然这里并不是收了广告费的，只是这个老师讲的确实不错，如果自学能力较差，像我，就必须有个老师引导，学习更得劲。当然了，大佬都是靠着<a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3C</a>网站的文档自学的，这个确实厉害。</p><p>跟着课程走，相关的笔记，我用了Xmind做详细记录（感觉没什么用，多实战才是关键），一些经典的处理，我会单独列举出来。</p><h4 id="引入图标字体">引入图标字体</h4><ol><li><p>引入图标字体库，一般都会选择在<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>官网下载</p></li><li><p>解压后，将<code>css,eot,svg,ttf,woff,woff2</code>文件复制到项目目录</p></li><li><p>在 <strong>APP.vue</strong> 文件中全局引入</p><pre class=" language-language-javascript"><code class="language-language-javascript">@import 'assets/fonts/iconfont.css';</code></pre></li><li><p>挑选相应图标并获取字体编码，应用于页面</p><pre class=" language-language-html"><code class="language-language-html"><span class="ifont">&#x33;</span></code></pre></li></ol><h3 id="前端框架——Vuejs">前端框架——Vuejs</h3><p>有了一些基础，再加上我这颗想要速成的心，我接着就看<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vuejs</a>相关的内容了，这里拿出一个常见的 UI 案例——<strong>Tabbar</strong>，作为练习。</p><h4 id="基本结构的搭建">基本结构的搭建</h4><p>首先看下图，这就是Tabbar的成品图，作为一个组件，其显示的内容完全由外界决定，，我们在封装的过程中，只需要设置基本的布局和样式即可。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Vuejs/tabbar.png" alt=""></p><p>基本的结构就是 <strong>div</strong> 的嵌套了，样式设置也没有什么技术含量：</p><pre class=" language-language-css"><code class="language-language-css">  #tab-bar {    display: flex;//设置为弹性盒布局    background-color: #f6f6f6;    position: fixed;  //固定布局    right: 0;    left: 0;    bottom: 0;//偏移至底部      //设置Tabbar顶端阴影    box-shadow: 0 -1px 1px rgba(100,100,100,.2);  }</code></pre><pre class=" language-language-css"><code class="language-language-css">.tab-bar-item {    flex: 1;    //子项平均分布    text-align: center; //文字居中    height: 49px;    font-size: 14px;    padding-top: -2px;  //一些细微调整}.tab-bar-item img{    width: 24px;    margin-top: 3px;    vertical-align: middle; //去除图片底部的空隙}.active{    color: #1296db; //文本颜色}</code></pre><h4 id="Tabbar组件的封装">Tabbar组件的封装</h4><p>具体的封装思路：</p><ul><li>定义插槽，用于设置Tabbar的每个子项Item</li><li>在Item中再设置三个插槽，用于对图标和文字的插入</li></ul><p>为什么Item中是三个插槽？因为点击Item时，为了更好的用户体验，往往会有图标的强调色，一次需要插入两个图标，而不是在点击时再插入。</p><pre class=" language-language-html"><code class="language-language-html"><!--  Tabbar 插槽，同于放置Item  --><div id="tab-bar">  <slot></slot></div></code></pre><pre class=" language-language-html"><code class="language-language-html"><!--  Item 插槽  --><div class="tab-bar-item" @click="itemClick">  <div v-if="isActive"><slot name="item-icon"></slot></div>  <div v-else><slot name="item-icon-active"></slot></div>  <div class="active"><slot name="item-text"></slot></div></div></code></pre><p><code>isActive</code>是一个计算属性，涉及到颜色控制，之后再详解；另一个就是，为了避免插槽再替换时，覆盖掉<code>v-if</code>和<code>v-else</code>，我们可以将插槽放入 <strong>div</strong> 中，并将它们作为 <strong>div</strong> 的属性。</p><h4 id="结合路由实现点击跳转">结合路由实现点击跳转</h4><p>静态的Tabbar已经差不多了，Tabbar主要的功能就是实现多个页面的跳转，主要步骤：</p><ul><li><p>创建页面的<code>.vue</code>文件</p></li><li><p>修改路由配置文件</p></li><li><p>设置点击方法</p></li></ul><pre class=" language-language-javascript"><code class="language-language-javascript">//路由 index.js 文件import Vue from 'vue'import Router from 'vue-router'//1. 安装插件Vue.use(Router);//使用懒加载，这里只做一个示例const Home = () => import('../views/home/Home');//2. 创建路由对象并导出export default new Router({  routes: [    {      path: '/',      redirect: '/home'    },    {      path: '/home',      component: Home    }  ]})</code></pre><p>点击方法的设置在<code>tab-bar-item</code>这个 <strong>div</strong> 中设置：</p><pre class=" language-language-html"><code class="language-language-html"><div class="tab-bar-item" @click="itemClick"></code></pre><p>跳转路由的代码：</p><pre class=" language-language-javascript"><code class="language-language-javascript">methods: {    itemClick(){        this.$router.replace(this.path);    }}</code></pre><h4 id="Tabbar的动态颜色控制">Tabbar的动态颜色控制</h4><p>到这里，整个<code>Tabbar</code>的封装已经差不多了，剩下的就是一个<code>TabBarItem</code>在细节性上的显示问题了，在点击事件产生时变色；此外作为一个封装的组件，其颜色的改变还需要由用户指定，而不能固定一个颜色，这里我们直接上代码：</p><p>首先，我们把固定的颜色样式删除，并在<code>TabBarItem</code>组件中添加如下代码：</p><pre class=" language-language-javascript"><code class="language-language-javascript">computed: {  isActive(){    return this.$route.path.indexOf(this.path) === -1  },  activeStyle(){    return this.isActive ? {} : {color: this.activeColor}  }},props: {  path: String,  activeColor: {    type: String,    default: '#1296db'  }}</code></pre><p>在App的模板中添加如下代码：</p><pre class=" language-language-html"><code class="language-language-html"><tab-bar>  <tab-bar-item path="/home" active-color="blue">    <img  slot="item-icon" src="./assets/img/tabbar/home.svg" alt="">    <img  slot="item-icon-active" src="./assets/img/tabbar/home_active.svg" alt="">    <div slot="item-text">首页</div>  </tab-bar-item></tab-bar></code></pre><p>也就是在父组件中向子组件TabBarItem中传入两个数据<code>path</code>和<code>active-color</code>,首先我们来看<code>isActive</code>这个计算属性，<code>indexOf</code>函数的作用时查看当前路由内的 <strong>path</strong> 值是否含有父组件传来的 <strong>path</strong> ，没有则返回 <strong>-1</strong>，<code>isActive</code>为<code>true</code>。</p><blockquote><p>The <code>indexOf()</code> method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns <strong>-1</strong> if the value is not found.</p></blockquote><p><code>active-color</code>参数则为传入的字体的颜色，字符串类型，如果忽略，则取默认值，首先要把html模板中的样式修改为：</p><pre class=" language-language-html"><code class="language-language-html"><div :style="activeStyle"><slot name="item-text"></slot></div></code></pre><p>用<code>v-bind</code>绑定一个样式属性，由<code>isActive</code>控制，即可实现颜色动态控制。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vuejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown进阶功能：用代码画流程图</title>
      <link href="/mk-2.html"/>
      <url>/mk-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="流程图基础">流程图基础</h2><p>首先我们先来了解下流程图的基础，这样才能更好的使用该工具。</p><p>流程图，是对某一个问题的定义、分析或解法的图形表示，图中用各种符号来表示操作、数据、流向以及装置等。</p><h3 id="流程图常用的符号及其含义">流程图常用的符号及其含义</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于office的一点点使用经验</title>
      <link href="/office.html"/>
      <url>/office.html</url>
      
        <content type="html"><![CDATA[<p>最近在期末复习，会经常性做一些电子笔记。难免会用到微软的office全家桶，对于一个没有系统性学过这些软件的我来说，遇到很多问题全靠百度过活，百度最有用的功能就是百度经验了，其次就是百度文库，PPT白嫖就是爽！</p><p>然后嘛，我特开此贴记录一下我遇到的问题，很弱智<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><h2 id="记录一次随机生成体温">记录一次随机生成体温</h2><ul><li><p>编辑日期<code>YYYY-MM-DD</code>，右下角鼠标拖动下拉</p></li><li><p>在单元格中，设置函数<code>=36.4+RAND()*0.4</code>，数值大小依据情况取值</p><blockquote><p>RAND() ：返回大于或等于0且小于1的平均分布的随机数</p></blockquote></li><li><p>重新整理数据，因为每次操作后数据都会重新生成，所以需要数据持久化</p><ul><li>选中所有数据复制</li><li>在其他空白区域粘贴，粘贴选项选择：<strong>值</strong>，来回即可</li><li>选中所有数据，单击工具栏<strong>数字格式</strong>，选择<strong>数值</strong>，保留一位小数</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>码字语法三千，我只取一瓢</title>
      <link href="/mk-1.html"/>
      <url>/mk-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="脚注">脚注</h2><pre class=" language-language-markdown"><code class="language-language-markdown">这是一个链接到老黄博客的脚注[^1]。[^1]: http://www.mahoo.design</code></pre><p>效果：这是一个链接到老黄博客的脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><h2 id="字体，颜色，大小">字体，颜色，大小</h2><pre class=" language-language-html"><code class="language-language-html"><font face="黑体">我是黑体字</font><font face="微软雅黑">我是微软雅黑</font><font face="STCAIYUN">我是华文彩云</font><font color=red>我是红色</font><font color=#008000>我是绿色</font><font color=Blue>我是蓝色</font><font size=5>我是尺寸为5</font><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font>$\color{black}{red}$专有名词专用</code></pre><p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="red">我是红色</font><br><font color="#008000">我是绿色</font><br><font color="Blue">我是蓝色</font><br><font size="5">我是尺寸为5</font><br><font face="黑体" color="green" size="5">我是黑体，绿色，尺寸为5</font></p><p>$\color{black}{red}$</p><h2 id="数学公式">数学公式</h2><h3 id="上下标">上下标</h3><ol><li>上标符号，符号：<code>^</code>，如：$x^4$            (x^4)</li><li>下标符号，符号：<code>_</code>，如：$x_1$            (x_1)</li><li>组合符号，符号：<code>{}</code>，如：${16}<em>{8}A{2}</em>{2}$         ({16}_{8}A{2}_{2})</li><li>取反，符号：<code>\prime</code>，如$D^\prime$</li></ol><h3 id="四则运算">四则运算</h3><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减加运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac{分子}{分母}</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>{分子} \over {分母}</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h3 id="逻辑运算">逻辑运算</h3><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li><li>远远大于运算，符号：<code>\gg</code>，如：$a \gg b$</li><li>远远小于运算，符号：<code>\ll</code>，如：$a \ll b$</li></ol><h3 id="累加累乘">累加累乘</h3><table><thead><tr><th>符号</th><th>代码</th></tr></thead><tbody><tr><td>$$\sum_{i=1}^n \frac{1}{i^2}$$</td><td><code>$\sum_{i=1}^n \frac{1}{i^2}$</code></td></tr><tr><td>$\prod_{i=1}^n \frac{1}{i^2}$</td><td><code>$\prod_{i=1}^n \frac{1}{i^2}$</code></td></tr><tr><td>$\bigcup_{i=1}^{2} R$</td><td><code>$\bigcup_{i=1}^{2} R$</code></td></tr><tr><td>$\bigcap_{i=1}^{2} R$</td><td><code>$\bigcap_{i=1}^{2} R$</code></td></tr></tbody></table><h3 id="积分运算">积分运算</h3><ol><li><p>积分符号 $\int$ ：<code>$\int$</code></p></li><li><p>双重积分符号$\iint$：<code>$\iint$</code></p></li><li><p>三重积分符号$\iiint$：<code>$\iiint$</code></p></li><li><p>曲线积分$\oint$：<code>$\oint$</code></p><p>实例：$\int_0^1 {x^2} ,{\rm d}x$      ——<code>$\int_0^1 {x^2} \,{\rm d}x$</code></p></li></ol><h3 id="多行格式">多行格式</h3><ol><li>$$y =\begin{cases} a \ b \ c\end{cases}$$ <code>y =\begin{cases} a \\ b \\ c\end{cases}</code></li></ol><h3 id="特殊符号">特殊符号</h3><table><thead><tr><th>符号</th><th>实现</th><th>描述</th></tr></thead><tbody><tr><td>$\bigotimes$</td><td><code>$\bigotimes$</code></td><td>克罗内克积</td></tr><tr><td>⨁</td><td><code>$\bigoplus$</code></td><td>异或</td></tr><tr><td>$\ldots$</td><td><code>$\ldots$</code></td><td>省略号</td></tr><tr><td>$\angle 30^\circ$</td><td><code>$\angle 30^\circ$</code></td><td>角度</td></tr><tr><td>$\uparrow$</td><td><code>$\uparrow$</code></td><td>向上</td></tr><tr><td>$\downarrow$</td><td><code>$\downarrow$</code></td><td>向下</td></tr><tr><td>$\leftarrow$</td><td><code>$\leftarrow$</code></td><td>向左</td></tr><tr><td>$\rightarrow$</td><td><code>$\rightarrow$</code></td><td>向右</td></tr><tr><td>$${\lim_{x \to +\infty}}$$</td><td><code>$${\lim_{x \to +\infty}}$$</code></td><td>极限</td></tr></tbody></table><h3 id="希腊字母">希腊字母</h3><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>$\mu$</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>$\nu$</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>$\omicron$</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>$\sigma$</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>$\Phi$</td><td><code>\Phi</code></td><td>$\phi$</td><td><code>\phi</code></td></tr><tr><td>$\Chi$</td><td><code>\Chi</code></td><td>$\chi$</td><td><code>\chi</code></td></tr><tr><td>$\Psi$</td><td><code>\Psi</code></td><td>$\psi$</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\Omega</code></td><td>$\omega$</td><td><code>\omega</code></td></tr><tr><td>$\varphi$</td><td><code>\varphi</code></td><td>$\varrho$</td><td><code>\varrho</code></td></tr></tbody></table><p>$$<br>\begin{cases}<br>1+1/2+\underbrace{1/3+1/4}<em>{&gt;1/2}+<br>\underbrace{1/5+1/6+1/7+1/8}</em>{&gt;1/2}+\cdots<br>\end{cases}<br>$$</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="http://www.mahoo.design" target="_blank" rel="noopener">http://www.mahoo.design</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python对文件进行批量重命名</title>
      <link href="/python-1.html"/>
      <url>/python-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="代码及相关详解">代码及相关详解</h2><p>最近没有在整STM32了，因为期末将近，必须花时间去预习了:joy:，但是还是忙里有偷闲，看到了以前看过的一些经典的影视作品动漫番剧，突然就想把这些作品的海报剧照等收藏起来，于是就淘遍整个网络下载下来好几百张图片，但是重命名就成了问题，Win10重命名的骚操作不会用，但是Python我会啊，谨以此文记录相关操作:wink:。</p><pre class=" language-language-python"><code class="language-language-python">import osimport timefilepath = 'D:\Mahoo\Pictures\Saved Pictures\收藏'n = 0# 开始计时time_start = time.time()for file in os.listdir(filepath):    # 拼接文件目录    filedir = os.path.join(filepath, file)    if os.path.isfile(filedir):        # 新文件名格式        newname = 'pic_' + str(n) + '.jpg'        n = n + 1        # 重命名        os.rename(filedir, os.path.join(filepath, newname))# 结束计时time_end = time.time()print('一共重命名{}次，耗时{:.3}秒 '.format(n, (time_end - time_start)))</code></pre><h3 id="os-path-isdir">os.path.isdir()</h3><p>该函数判断某一路径是否为目录，返回一个<code>Bool</code>值：</p><pre class=" language-language-python"><code class="language-language-python">import os# 判断D:\Mahoo\pic是否为文件os.path.isfile('D:\\Mahoo\\pic')</code></pre><p>类似的即是<code>os.path.isfile()</code>，功能都可以顾名思义<strong>判断是否为文件</strong>。</p><h3 id="os-path-join">os.path.join()</h3><p>该函数将多个路径组合后返回，例如：</p><pre class=" language-language-python"><code class="language-language-python">path1 = 'D:\Mahoo'path2 = 'Pictures'path3  =  os.path.join(path1,path2)print(path3)# D:\Mahoo\Pictures</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习Demo</title>
      <link href="/python-demo.html"/>
      <url>/python-demo.html</url>
      
        <content type="html"><![CDATA[<h1>Python学习Demo</h1><h2 id="1-1-输入输出">1.1 输入输出</h2><ul><li><p>使用input()函数获取键盘输入</p><pre class=" language-language-python"><code class="language-language-python">a = int(input('a = '))</code></pre></li><li><p>使用getpass，输入无回显</p><pre class=" language-language-python"><code class="language-language-python">import getpassusername = input('请输入用户名: ')password = getpass.getpass('请输入密码: ')if username == 'admin' and password == '123456':    print('登录成功!')else:    print('登录失败!')</code></pre></li></ul><h3 id="格式化输出">格式化输出</h3><h4 id="进制输出">进制输出</h4><p><code>%o</code> —— oct  八进制<br><code>%d</code> —— dec 十进制<br><code>%x</code> —— hex 十六进制</p><pre class=" language-language-python"><code class="language-language-python">print('%o' % 20)# 24print('%d' % 20)# 20print('%x' % 20)# 14</code></pre><h4 id="浮点输出">浮点输出</h4><p><code>%f </code>——保留小数点后面六位有效数字<br>　　%.3f，保留3位小数位<br><code>%e</code> ——保留小数点后面六位有效数字，指数形式输出<br>　　%.3e，保留3位小数位，使用<strong>科学计数法</strong><br><code>%g</code> ——在保证六位有效数字的前提下，使用小数方式，否则使用科学计数法<br>　　%.3g，保留3位有效数字，使用<strong>小数或科学计数法</strong></p><h4 id="format用法">format用法</h4><p><code>format()</code>功能极其强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号<code>{}</code>作为特殊字符代替<code>%</code>，并且<code>{}</code>还可以<em><strong>加入编号或关键字控制输入</strong></em>：</p><pre class=" language-language-python"><code class="language-language-python">print('{} {}'.format('hello','world'))  # 不带字段hello worldprint('{0} {1}'.format('hello','world'))  # 带数字编号hello worldprint('{0} {1} {0}'.format('hello','world'))  # 打乱顺序hello world helloprint('{1} {1} {0}'.format('hello','world'))world world helloprint('{a} {tom} {a}'.format(tom='hello',a='world'))  # 带关键字world hello world# 数字格式化print("{:.2f}".format(3.1415926));# 3.14</code></pre><table><thead><tr><th style="text-align:center">数字·</th><th style="text-align:center">格式</th><th style="text-align:center">输出</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">3.1415926</td><td style="text-align:center">{:.2f}</td><td style="text-align:center">3.14</td><td style="text-align:left">保留小数点后两位</td></tr><tr><td style="text-align:center">3.1415926</td><td style="text-align:center">{:+.2f}</td><td style="text-align:center">+3.14</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:center">-1</td><td style="text-align:center">{:+.2f}</td><td style="text-align:center">-1.00</td><td style="text-align:left">带符号保留小数点后两位</td></tr><tr><td style="text-align:center">2.71828</td><td style="text-align:center">{:.0f}</td><td style="text-align:center">3</td><td style="text-align:left">不带小数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">{:0&gt;2d}</td><td style="text-align:center">05</td><td style="text-align:left">数字补零 (填充左边, 宽度为2)</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">{:x&lt;4d}</td><td style="text-align:center">5xxx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">{:x&lt;4d}</td><td style="text-align:center">10xx</td><td style="text-align:left">数字补x (填充右边, 宽度为4)</td></tr><tr><td style="text-align:center">1000000</td><td style="text-align:center">{:,}</td><td style="text-align:center">1,000,000</td><td style="text-align:left">以逗号分隔的数字格式</td></tr><tr><td style="text-align:center">0.25</td><td style="text-align:center">{:.2%}</td><td style="text-align:center">25.00%</td><td style="text-align:left">百分比格式</td></tr><tr><td style="text-align:center">1000000000</td><td style="text-align:center">{:.2e}</td><td style="text-align:center">1.00e+09</td><td style="text-align:left">指数记法</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">{:&gt;10d}</td><td style="text-align:center">13</td><td style="text-align:left">右对齐 (默认, 宽度为10)</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">{:&lt;10d}</td><td style="text-align:center">13</td><td style="text-align:left">左对齐 (宽度为10)</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">{:^10d}</td><td style="text-align:center">13</td><td style="text-align:left">中间对齐 (宽度为10)</td></tr></tbody></table><table><thead><tr><th>进制控制</th><th>输出</th></tr></thead><tbody><tr><td>‘{:b}’.format(11)</td><td>1011</td></tr><tr><td>‘{:d}’.format(11)</td><td>11</td></tr><tr><td>‘{:o}’.format(11)</td><td>13</td></tr><tr><td>‘{:x}’.format(11)</td><td>b</td></tr><tr><td>‘{:#x}’.format(11)</td><td>0xb</td></tr><tr><td>‘{:#X}’.format(11)</td><td>0XB</td></tr></tbody></table><h2 id="1-2-条件">1.2 条件</h2><ul><li><p>if…else的嵌套</p><pre class=" language-language-python"><code class="language-language-python">x = float(input('x = '))if x > 1:    y = 3 * x - 2else:    if x >= -1:        y = x + 2    else:        y = 5 * x + 3print('f(%.2f) = %.2f' % (x, y))</code></pre></li><li><p>if…elif…else的嵌套</p><pre class=" language-language-python"><code class="language-language-python">x = float(input('x = '))if x > 1:    y = 3 * x - 5elif x >= -1:    y = x + 2else:    y = 5 * x + 3print('f(%.2f) = %.2f' % (x,y))</code></pre></li></ul><h2 id="1-3-循环">1.3 循环</h2><ul><li><p>for-in循环</p><pre class=" language-language-python"><code class="language-language-python">"""用for循环实现1-100求和"""sum = 0for x in range(101):sum += xprint(sum)</code></pre><p><strong>注意</strong>：<code>range</code>可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如：</p><ul><li><code>range(101)</code>可以产生一个0到100的整数序列。</li><li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li><li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li></ul></li><li><p>for循环实现1-100偶数求和</p><pre class=" language-language-python"><code class="language-language-python">sum_even = 0for x in range(2,100,2):    sum_100_even += xprint(sum_even)</code></pre></li><li><p>while循环</p><pre class=" language-language-python"><code class="language-language-python">import randomanswer = random.randint(1, 100)while True:    number = int(input('请输入数字：'))    if number > answer:        print("大了")    elif number < answer:        print("小了")    else:        print("猜对了")   break</code></pre></li><li><p>求取水仙花数</p></li></ul><pre class=" language-language-python"><code class="language-language-python">for x in range(100,1000):    a = x // 100    b = x // 10 % 10    c = x % 10    if a ** 3 + b ** 3 + c ** 3 == x:        print(x)</code></pre><h2 id="1-5-模块">1.5 模块</h2><ul><li><p>random模块的randint函数</p><pre class=" language-language-python"><code class="language-language-python">from random import randintnum = randint(1,4)if num == 1:    result = 'A'elif num == 2:    result = 'B'elif num == 3:    result = 'C'elif num == 4:    result = 'D'print(result)</code></pre></li><li><p>math模块, abs()取绝对值</p><pre class=" language-language-python"><code class="language-language-python">a = -4b = 9c = math.sqrt(abs(a) + b)print(c)</code></pre></li></ul><p>如果我们导入的模块除了定义函数之外还中有可以执行代码，<strong>那么Python解释器在导入这个模块时就会执行这些代码</strong>，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。</p><p><a href="http://module.py" target="_blank" rel="noopener">module.py</a></p><pre class=" language-language-python"><code class="language-language-python">def foo():    passdef bar():    pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == '__main__':    print('call foo()')    foo()    print('call bar()')    bar()</code></pre><p><a href="http://test.py" target="_blank" rel="noopener">test.py</a></p><pre class=" language-language-python"><code class="language-language-python">import module# 导入module时 不会执行模块中if条件成立时的代码 因为模块的名字是module而不是__main__</code></pre><h2 id="1-6-函数">1.6 函数</h2><pre class=" language-language-python"><code class="language-language-python"># 在参数名前面的*表示args是一个可变参数# 即在调用add函数时可以传入0个或多个参数def add(*args):    total = 0    for val in args:        total += val    return totalprint(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))</code></pre><h2 id="1-7-字符串，列表，元组">1.7 字符串，列表，元组</h2><ul><li><p>字符串</p><pre class=" language-language-python"><code class="language-language-python">str1 = 'hello, world!'    # 通过len函数计算字符串的长度    print(len(str1))  # 13    # 获得字符串首字母大写的拷贝    print(str1.capitalize())  # Hello, world!    # 获得字符串变大写后的拷贝    print(str1.upper())  # HELLO, WORLD!    # 从字符串中查找子串所在位置    print(str1.find('or'))  # 8    print(str1.find('shit'))  # -1    # 与find类似但找不到子串时会引发异常    # print(str1.index('or'))    # print(str1.index('shit'))    # 检查字符串是否以指定的字符串开头    print(str1.startswith('He'))  # False    print(str1.startswith('hel'))  # True    # 检查字符串是否以指定的字符串结尾    print(str1.endswith('!'))  # True    # 将字符串以指定的宽度居中并在两侧填充指定的字符    print(str1.center(50, '*'))    # 将字符串以指定的宽度靠右放置左侧填充指定的字符    print(str1.rjust(50, ' '))    str2 = 'abc123456'    # 从字符串中取出指定位置的字符(下标运算)    print(str2[2])  # c    # 字符串切片(从指定的开始索引到指定的结束索引)    print(str2[2:5])  # c12    print(str2[2:])  # c123456    print(str2[2::2])  # c246 序列每次递增2    print(str2[::2])  # ac246    print(str2[::-1])  # 654321cba    print(str2[-3:-1])  # 45 倒数第三到倒数第一    # 检查字符串是否由数字构成    print(str2.isdigit())  # False    # 检查字符串是否以字母构成    print(str2.isalpha())  # False    # 检查字符串是否以数字和字母构成    print(str2.isalnum())  # True    str3 = '  mahoo12138@qq.com '    print(str3)    # 获得字符串修剪左右两侧空格的拷贝    print(str3.strip())</code></pre><ul><li><p>字符串前加<code>r</code>表示该字符串为raw string，可以防止字符串被转义，一般多用于正则表达式：</p><pre class=" language-language-python"><code class="language-language-python">str = r"\n\n\n"print(str)# \n\n\n</code></pre></li><li><p>字符串搜索&amp;替换</p><p>使用 str.replace()</p><pre class=" language-language-python"><code class="language-language-python">text="mahoo is a handsome boy"print(text.replace("boy","girl"))  # mahoo is a handsome girl</code></pre><p>复杂的模式，请使用 re 模块中的 <code>sub() </code>函数</p><pre class=" language-language-python"><code class="language-language-python"># 假设你想将形式为 11/27/2018 的日期字符串改成 2018-11-27import redate="11/27/2018"print(re.sub(r"(\d+)/(\d+)/(\d+)",r"\3-\1-\2",date))  # 2018-11-27# sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号</code></pre><p>转自：<a href="https://www.cnblogs.com/zzy-9318/" target="_blank" rel="noopener">朱兆筠</a>  —— <a href="https://www.cnblogs.com/zzy-9318/p/10457921.html" target="_blank" rel="noopener">Python之字符串搜索和替换</a></p><h3 id=""></h3></li></ul></li><li><p>列表</p><pre class=" language-language-python"><code class="language-language-python">list1 = [1, 3, 5, 7, 100]    print(list1)#[1, 3, 5, 7, 100]    list2 = ['hello'] * 5    print(list2)#['hello', 'hello', 'hello', 'hello', 'hello']    # 计算列表长度(元素个数)    print(len(list1))#5    # 下标(索引)运算    print(list1[0])#1    print(list1[4])#100    # print(list1[5])  # IndexError: list index out of range    # 索引为-1，则访问最后一个元素    print(list1[-1])    print(list1[-3])    list1[2] = 300    print(list1)    # 添加元素    list1.append(200)    list1.insert(1, 400)#在序列1前面插入元素400    list1 += [1000, 2000]#添加元素在末尾    # 删除元素    list1.remove(3)#移除该元素，没有则报错    if 1234 in list1:        list1.remove(1234)    del list1[0]#删除序列0的元素    # 清空列表元素    list1.clear()</code></pre><ul><li><p>列表排序</p><pre class=" language-language-python"><code class="language-language-python">list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']    list2 = sorted(list1)# 根据字母表排序    # sorted函数返回列表排序后的拷贝不会修改传入的列表    list3 = sorted(list1, reverse=True)# 根据字母表反向排序        # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序    list4 = sorted(list1, key=len)        # 给列表对象发出排序消息直接在列表对象上进行排序    list1.sort(reverse=True)    print(list1)</code></pre></li></ul></li><li><p>创建列表</p><pre class=" language-language-python"><code class="language-language-python">f = [x for x in range(1, 10)]    print(f)    f = [x + y + z for x in 'AB' for y in '12' for z in '!@']print(f)    # ['A1!', 'A1@', 'A2!', 'A2@', 'B1!', 'B1@', 'B2!', 'B2@']    # 用列表的生成表达式语法创建列表容器    # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间    import sys    f = [x ** 2 for x in range(1, 6)]    print(sys.getsizeof(f))  # 查看对象占用内存的字节数    print(f)    # 请注意下面的代码创建的不是一个列表而是一个生成器对象    # 通过生成器可以获取到数据但它不占用额外的空间存储数据    # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)    f = (x ** 2 for x in range(1, 6))    print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间    print(f)    for val in f:        print(val)</code></pre></li><li><p>二维列表</p><ul><li><p>创建List二维列表</p><pre class=" language-language-python"><code class="language-language-python">lists = [[] for i in range(3)]  # 创建的是多行三列的二维列表for i in range(3):    lists[0].append(i)for i in range(5):    lists[1].append(i)for i in range(7):    lists[2].append(i)print("lists is:", lists)# lists is: [[0, 1, 2], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5, 6]]</code></pre></li><li><p>使用索引遍历二维列表</p><pre class=" language-language-python"><code class="language-language-python">sum_0 = 0for i in range(len(lists)):    for j in range(len(lists[i])):        print(lists[i][j])        sum_0 += lists[i][j]print("The sum_0 of Lists:", sum_0)# 0# 1# 2# 0# 1# 2# 3# 4# 0# 1# 2# 3# 4# 5# 6# The sum of Lists: 34</code></pre></li><li><p>使用句柄遍历二维列表</p><pre class=" language-language-python"><code class="language-language-python">sum_1 = 0for i in lists:    for j in i:        sum_1 += jprint("The sum_1 of Lists:", sum_1)# The sum_1 of Lists: 34</code></pre><p>转自：cloud&amp;ken —— <a href="https://www.cnblogs.com/cloud-ken/p/10019253.html" target="_blank" rel="noopener">python创建与遍历List二维列表</a></p><h3 id="使用元组">使用元组</h3><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改</p><pre class=" language-language-python"><code class="language-language-python"> # 定义元组    t = ('老黄', 19, True, '大连')    print(t)    # 获取元组中的元素    print(t[0])    print(t[3])    # 遍历元组中的值    for member in t:        print(member)    # 重新给元组赋值    # t[0] = '王大锤'  # TypeError    # 变量t重新引用了新的元组原来的元组将被垃圾回收    t = ('老王', 40, True, '湖南')    print(t)    # 将元组转换成列表    person = list(t)    print(person)    # 列表是可以修改它的元素的    person[0] = '李小龙'    person[1] = 25    print(person)    # 将列表转换成元组    fruits_list = ['apple', 'banana', 'orange']    fruits_tuple = tuple(fruits_list)    print(fruits_tuple)</code></pre></li></ul></li></ul><h2 id="1-8-yield关键字">1.8 yield关键字</h2><ul><li><p>Python关键字yield的解释</p><ul><li><p>可迭代对象</p><p>一个列表，可以逐项地读取，这叫做一个可迭代对象:</p><pre class=" language-language-python"><code class="language-language-python">list = [1, 2, 3]for i in list:print(i)</code></pre></li><li><p>生成器</p><p>生成器是可以迭代的，但是你 <strong>只可以读取它一次</strong> ，因为它并不把所有的值放在内存中，它是实时地生成数据:</p><pre class=" language-language-python"><code class="language-language-python">mygenerator = (x*x for x in range(3))for i in mygenerator:print(i)</code></pre></li></ul><p>看起来除了把 <code>[]</code> 换成 <code>()</code> 外没什么不同。但是，你不可以再次使用 <code>for i inmygenerator</code> , 因为生成器只能被迭代一次：先计算出0，然后继续计算1，然后计算4，一个跟一个的…</p><ul><li><p>yield关键字</p><p><code>yield</code> 是一个类似 <code>return</code> 的关键字，<strong>只是这个函数返回的是个生成器</strong>。</p><pre class=" language-language-python"><code class="language-language-python">def createGenerator() :    mylist = range(3)    for i in mylist :        yield i*imygenerator = createGenerator()print(mygenerator)# mygenerator 是一个对象<generator object createGenerator at 0x000001D74701D8C8>for i in mygenerator:     print(i)</code></pre><p>这个例子没什么用途，但是它让你知道，这个函数会返回一大批你只需要读一次的值.</p></li></ul></li></ul><h2 id="1-9-类的使用">1.9 类的使用</h2><ul><li><p>定义类</p><p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p><pre class=" language-language-python"><code class="language-language-python">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age    def study(self, course_name):        print('%s正在学习%s.' % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age < 18:            print('%s只能观看《熊出没》.' % self.name)        else:            print('%s正在观看岛国爱情大电影.' % self.name)</code></pre><blockquote><p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p></blockquote></li><li><p>创建和使用对象</p><pre class=" language-language-python"><code class="language-language-python">def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('我', 20)    # 给对象发study消息    stu1.study('Python程序设计')    # 给对象发watch_av消息    stu1.watch_movie()    stu2 = Student('王大锤', 15)    stu2.study('思想品德')    stu2.watch_movie()if __name__ == '__main__':    main()</code></pre></li><li><p>访问的可见性</p><p>在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。</p><pre class=" language-language-python"><code class="language-language-python">class Test:    def __init__(self, foo):        self.__foo = foo    def __bar(self):        print(self.__foo)        print('__bar')def main():    test = Test('hello')    # AttributeError: 'Test' object has no attribute '__bar'    test.__bar()    # AttributeError: 'Test' object has no attribute '__foo'    print(test.__foo)if __name__ == "__main__":    main()</code></pre><p>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。</p><pre class=" language-language-python"><code class="language-language-python">class Test:    def __init__(self, foo):        self.__foo = foo    def __bar(self):        print(self.__foo)        print('__bar')def main():    test = Test('hello')    test._Test__bar()    print(test._Test__foo)if __name__ == "__main__":    main()</code></pre><p>在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻。</p></li></ul><h2 id="2-0-文件操作">2.0 文件操作</h2><ul><li>操作模式</li></ul><table><thead><tr><th style="text-align:center">操作模式</th><th style="text-align:left">具体含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>'r'</code></td><td style="text-align:left">读取 （默认）</td></tr><tr><td style="text-align:center"><code>'w'</code></td><td style="text-align:left">写入（会先截断之前的内容）</td></tr><tr><td style="text-align:center"><code>'x'</code></td><td style="text-align:left">写入，如果文件已经存在会产生异常</td></tr><tr><td style="text-align:center"><code>'a'</code></td><td style="text-align:left">追加，将内容写入到已有文件的末尾</td></tr><tr><td style="text-align:center"><code>'b'</code></td><td style="text-align:left">二进制模式</td></tr><tr><td style="text-align:center"><code>'t'</code></td><td style="text-align:left">文本模式（默认）</td></tr><tr><td style="text-align:center"><code>'+'</code></td><td style="text-align:left">更新（既可以读又可以写）</td></tr></tbody></table><h3 id="读写文本文件">读写文本文件</h3><ul><li><p>使用<code>open()</code>函数</p><ul><li><p>文件名 (指定路径)</p></li><li><p>文件模式</p></li><li><p>编码参数</p></li></ul><pre class=" language-language-python"><code class="language-language-python">def main():    f = open('mahoo.txt', 'r', encoding='utf-8')    print(f.read())    f.close()if __name__ == '__main__':    main()</code></pre></li></ul><h2 id="-2"></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那个深秋的夜晚——与ADC的浪漫邂逅</title>
      <link href="/stm32-4.html"/>
      <url>/stm32-4.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="ADC简介">ADC简介</h2><p>STM32f103 系列有 3 个 ADC，精度为 12 位，每个 ADC 最多有 16 个外部通道，可测量16个外部和2个内部信号源。其中ADC1 和 ADC2 都有 16 个外部通道，ADC3 根据 CPU 引脚的不同通道数也不同，一般都有8 个外部通道。</p><p>ADC的结果可以左对齐或右对齐方式存储在16位数据寄存器中。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/adc.png" alt="单个ADC框图"></p><h3 id="电压输入范围">电压输入范围</h3><p>输入电压：$V_{REF-} \leq V_{IN} \leq V_{REF+}$，决定输入电压的引脚：$V_{REF-}, V_{REF+},VDDA,VSSA$，把$VSSA$和$V_{REF-}$接地，$V_{REF+}$和$VDDA$接$3.3V$，得到ADC的输入电压范围为：<mark>0~3.3V</mark>。</p><blockquote><p>VDD： D即device 表示器件的意思，是器件内部的工作电压。</p><p>VDDA(A表示 Analog 【模拟】)是模拟电源，当使用到模拟信号的时候，比如AD（模数）或者DA（数模）的时候，系统会使用VDDA的电压作为参考电压来。不要求精准使用的话，可以直接把VDDA和VDD同时接入$3.3V$就行。如果要求精准，则需要做一个稳压电路，再接入VDDA 。</p><p>VSS：S即series 表示公共连接的意思，通常指电路公共接地端电压 ，VSSA同理为模拟部分的电源。</p><p>对于数字电路来说，VCC是电路的供电电压,VDD是芯片的工作电压(通常$VCC&gt;VDD$)，$VSS$是接地点。<br>例如，对于ARM单片机来说，其供电电压$VCC$一般为5V，一般经过稳压模块将其转换为单片机工作电压$VDD = 3.3V$。</p></blockquote><h4 id="定制电压范围">定制电压范围</h4><p>例如将电压范围设成$-10V$~ $10V$，可以通过下图的附加扩展电路实现：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/-10~10.png" alt="附加电路"></p><p>根据基尔霍夫定律（KCL），即节点流入的电流等于流出的电流可以得到：<br>$$<br>{(V_{IN}-V_{OUT})\over 2 } + {(3.3V-V_{OUT})\over R_1 } = {V_{OUT} \over R_3}<br>$$<br>解得： $V_{OUT}={(V_{IN}+ 10)\over 6}$</p><p>在附加电路的条件下，当$V_{IN}=-10V$时，$V_{OUT}=0$；当$V_{IN}=10V$时，$V_{OUT}=3.3V$。以此达到测量$-10V$~ $10V$电压的目的。</p><h3 id="输入通道">输入通道</h3><p>输入通道，顾名思义为将电压输入到ADC的通道，STM32 的 ADC 多达 18 个通道，具体参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93.png" alt="输入通道"></p><p>外部的 16 个通道在转换的时候又分为规则通道和注入通道，其中规则通道最多有 16路，注入通道最多有 4 路。</p><ul><li>规则通道：也就是一般情况下用到的通道；</li><li>注入通道：可以在规则通道转换的时候强行插入转换，享有转换特权，有点像中断的操作。</li></ul><h3 id="转换顺序">转换顺序</h3><ul><li><p>规则序列</p><p>转换的优先级并不是根据通道的编号来确定的，需要操作规则序列寄存器<code>SQRx</code>(x=1,2,3)，例如将通道六设置为第十个转换，SQ10这个位写6即可。SQL1中SQL位用于设置转换通道的数量，具体的操作都可以库函数代劳。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/%E8%BD%AC%E6%8D%A2%E9%A1%BA%E5%BA%8F_%E8%A7%84%E5%88%99.png" alt="规则序列"></p></li><li><p>注入序列</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/%E8%BD%AC%E6%8D%A2%E9%A1%BA%E5%BA%8F_%E6%B3%A8%E5%85%A5.png" alt="注入序列"></p><p>注入序列的转换顺序稍有不一样，当<code>JL</code>的值小于<code>4</code>时，第一次转的顺序是<code>JSQx</code>(x=4-JL)；当JL等于4时，与SQR一致。</p></li></ul><h3 id="触发源">触发源</h3><p>触发源可以看作是系统给ADC这个外设的一个信号，当触发源激活时，ADC就开始进行转换。触发源一般有两种：软件触发和外部事件触发（包括内部定时器和外部IO）；</p><ul><li><p>软件触发</p><p>在<code>ADC_CR2</code>的<code>ADON</code>位写1，开始转换；</p></li><li><p>外部事件触发</p><p>外部触发源很多，不在此详叙，主要经过<code>EXTSEL[2:0]</code>和 <code>JEXTSEL[2:0]</code>位来选择，<code>EXTTRIG</code> 和<code>JEXTTRIG</code>这两位来激活。</p></li></ul><h3 id="转换时间">转换时间</h3><h4 id="ADC时钟">ADC时钟</h4><p>ADC 输入时钟 ADC_CLK 由 PCLK2 经过分频产生，最大是 14M，分频因子由 RCC 时钟配置寄存器<code> RCC_CFGR</code> 的位 15:14 <code>ADCPRE[1:0]</code>设置，可以是 2/4/6/8 分频，注意这里没有 1 分频。一般我们设置 $PCLK2=HCLK=72M$。</p><h4 id="采样时间">采样时间</h4><p>ADC 使用若干个 <code>ADC_CLK</code> 周期对输入的电压进行采样，采样的周期数可通过 ADC 采样时间寄存器 <code>ADC_SMPR1</code> 和 <code>ADC_SMPR2</code> 中的 <code>SMP[2:0]</code>位设置，ADC_SMPR2 控制的是通道 0<sub>9，<code>ADC_SMPR1 </code>控制的是通道 10</sub>17。每个通道可以分别用不同的时间采样。其中采样周期最小是 1.5 个，即如果我们要达到最快的采样，那么应该设置采样周期为 1.5个周期，这里说的周期就是$ 1\over ADC_{CLK}$。</p><p>ADC 的转换时间跟 ADC 的输入时钟和采样时间有关，公式为：<br>$$<br>Tconv = 采样时间 + 12.5 个周期。<br>$$<br>当 $ADCLK = 14MHZ$ （最高），采样时间设置为 1.5 周期（最快），那么总的转换时间（最短）$T_{conv}$ = 1.5 周期 + 12.5 周期 = 14 周期 = 1us。一般我们设置 $PCLK2=72M$，经过 ADC 预分频器能分频到最大的时钟只能是 12M，采样周期设置为 1.5 个周期，算出最短的转换时间为 1.17us，这个才是最常用的。</p><h3 id="数据寄存器">数据寄存器</h3><p>ADC转换后，规则组数据存放在<code>ADC_DR</code>寄存器中，注入组在<code>JDRx</code>。</p><h4 id="规则数据寄存器">规则数据寄存器</h4><p>ADC 规则组数据寄存器 <code>ADC_DR</code> 只有一个，是一个 32 位的寄存器，低 16 位在单 ADC时使用，高 16 位是在 ADC1 中双模式下保存 ADC2 转换的规则数据，双模式就是 ADC1 和ADC2 同时使用。在单模式下，ADC1/2/3 都不使用高 16 位。因为 ADC 的精度是 12 位，<br>无论<code> ADC_DR</code> 的高 16 或者低 16 位都放不满，只能左对齐或者右对齐，具体是以哪一种方式存放，由 <code>ADC_CR2</code> 的 11 位 <code>ALIGN </code>设置。</p><p>由于数据寄存器只有一个，而通道却有多个，<strong>多通道转换时为了避免数据被覆盖，转换完成时应立刻将数据取走</strong>，一般开启<code>DMA</code>传输模式，直接将数据传输给变量。</p><h4 id="注入数据寄存器">注入数据寄存器</h4><p>ADC 注入组最多有 4 个通道，刚好注入数据寄存器也有 4 个，每个通道对应着自己的寄存器，不会跟规则寄存器那样产生数据覆盖的问题。<code>ADC_JDRx</code> 是 32 位的，低 16 位有效，高 16 位保留，数据同样分为左对齐和右对齐，具体是以哪一种方式存放，由<br><code>ADC_CR2</code> 的 11 位<code> ALIGN</code> 设置。</p><h3 id="中断">中断</h3><h4 id="转换结束中断">转换结束中断</h4><p>数据转换结束后，可以产生中断，中断分为三种：</p><ul><li><p>*规则通道转换结束中断，*对应中断位：<code>ADC_IT_EOC</code>;</p></li><li><p>*注入转换通道转换结束中断，*对应中断位：<code>ADC_IT_JEOC</code>;</p></li><li><p><em>模拟看门狗中断</em>，对应中断位：<code>ADC_IT_AWD</code>。</p></li></ul><h4 id="模拟看门狗中断">模拟看门狗中断</h4><p>当被 ADC 转换的模拟电压低于低阈值或者高于高阈值时，就会产生中断，<strong>前提是我们开启了模拟看门狗中断</strong>，其中低阈值和高阈值由 <code>ADC_LTR</code> 和 <code>ADC_HTR</code> 设置。例如我们设置的电压高阈值为3.3V，若接入的模拟电压高于3.3V时，即产生中断。</p><h4 id="DMA-请求">DMA 请求</h4><p>规则和注入通道转换结束后，除了产生中断外，还可以产生 DMA 请求，把转换好的数据直接存储在内存里面。要注意的是<strong>只有 ADC1 和 ADC3 可以产生 DMA 请求</strong>。</p><h3 id="双-ADC-模式">双 ADC 模式</h3><p>AD 转换包括采样阶段和转换阶段，在采样阶段才对通道数据进行采集；而在转换阶段只是将采集到的数据进行转换为数字量输出，此刻通道数据变化不会改变转换结果。独立模式的 ADC 采集需要在一个通道采集并且转换完成后才会进行下一个通道的采集。而双重 ADC 的机制就是使用两个 ADC 同时采样一个或者多个通道。双重 ADC 模式较独立模式一个最大的优势就是提高了采样率，弥补了单个 ADC 采样不够快的缺点。</p><p>启用双 ADC 模式的时候，通过配置 <code>ADC_CR1 </code>寄存器的<code> DUALMOD[3:0]</code>位，可以有几种不同的模式：</p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:left">简介</th></tr></thead><tbody><tr><td style="text-align:center">同步注入模式</td><td style="text-align:left">ADC1 和 ADC2 同时转换一个注入通道组，其中 ADC1 为主，ADC2 为从。转换的数据存储在每个 ADC 接口的<code>ADC_JDRx</code>寄存器中。</td></tr><tr><td style="text-align:center">同步规则模式</td><td style="text-align:left">ADC1 和 ADC2 同时转换一个规则通道组，其中 ADC1 为主，ADC2 为从。ADC1 转换的结果放在 <code>ADC1_DR</code> 的低 16 位，ADC2 转换的结果放在 <code>ADC1_DR</code> 的高十六位。</td></tr><tr><td style="text-align:center">快速交叉模式</td><td style="text-align:left">ADC1 和 ADC2 交替采集一个规则通道组（通常为一个通道）。当ADC2 触发之后，ADC1 需要等待 <mark>7</mark>个<code> ADCCLK</code> 之后才能触发。</td></tr><tr><td style="text-align:center">慢速交叉模式</td><td style="text-align:left">ADC1 和 ADC2 交替采集一个规则通道组（只能为一个通道）。当ADC2 触发之后，ADC1 需要等待 <mark>14</mark> 个<code> ADCCLK</code> 之后才能触发。</td></tr><tr><td style="text-align:center">交替触发模式</td><td style="text-align:left">ADC1 和 ADC2 轮流采集注入通道组，当 ADC1 所有通道采集完毕之后再采集 ADC2 的通道，如此循环。跟交叉采集不一样。</td></tr><tr><td style="text-align:center">混合的规则/注入同步模式</td><td style="text-align:left">规则组同步转换被中断，以启动注入组的同步转换。分开两个模式来理解就可以了，区别就是注入组可以中断规则组的转换。</td></tr><tr><td style="text-align:center">混 合 的 同 步 规则+交替触发模式</td><td style="text-align:left">规则组同步转换被中断，以启动注入组交替触发转换。分开两个模式来理解就可以了，区别就是注入组可以中断规则组的转换。</td></tr><tr><td style="text-align:center">混合同步注入+交叉模式</td><td style="text-align:left">交叉转换可以被同步注入模式中断。这种情况下，交叉转换被中断，注入转换被启动。</td></tr></tbody></table><h2 id="例程设计">例程设计</h2><p>STM32 的 ADC 功能繁多，以下通过三个基础例程尽量展示ADC的功能，代码中均没有使用宏定义，是为了看得更直观。</p><h3 id="独立模式单通道">独立模式单通道</h3><p>**1) **初始 ADC 用到的 GPIO，这里我们以<code>GPIOC1</code>为例：</p><pre class=" language-language-c"><code class="language-language-c">void ADCx_GPIO_Config(void){    GPIO_InitTypeDef GPIO_InitStructure;    // 打开 ADC IO 端口时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);    // 配置 ADC IO 引脚模式// 必须为模拟输入GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;// 初始化 ADC IOGPIO_Init(GPIOC, &GPIO_InitStructure); }</code></pre><p><strong>2)</strong> 设置 ADC 的工作参数并初始化（以ADC1为例）；</p><pre class=" language-language-c"><code class="language-language-c">void ADCx_Mode_Config(void){    ADC_InitTypeDef ADC_InitStructure;    // 打开 ADC 时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);    // ADC 模式配置// 只使用一个 ADC，属于独立模式    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;        // 禁止扫描模式，多通道才要，单通道不需要    ADC_InitStructure.ADC_ScanConvMode = DISABLE;        // 连续转换模式    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;        // 不用外部触发转换，软件开启即可    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;// 转换结果右对齐    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;    // 转换通道 1 个    ADC_InitStructure.ADC_NbrOfChannel = 1;// 初始化 ADCADC_Init(ADC1, &ADC_InitStructure);    // 配置ADC时钟为PCLK2的8分频，即9MHzRCC_ADCCLKConfig(RCC_PCLK2_Div8); // 配置 ADC 通道转换顺序和采样时间ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1, ADC_SampleTime_55Cycles5);    /**      * @param1 ADC 外设      * @param2 通道选择      * @param3 转换顺序 1~16      * @param4 采样周期  */// ADC 转换结束产生中断，在中断服务程序中读取转换值ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);// 开启ADC，并开始转换ADC_Cmd(ADC1, ENABLE);// 初始化ADC 校准寄存器  ADC_ResetCalibration(ADC1);// 等待校准寄存器初始化完成while(ADC_GetResetCalibrationStatus(ADC1));// ADC开始校准ADC_StartCalibration(ADC1);// 等待校准完成while(ADC_GetCalibrationStatus(ADC1));// 由于没有采用外部触发，所以使用软件触发ADC转换 ADC_SoftwareStartConvCmd(ADC1, ENABLE);}</code></pre><p>**3) **配置中断源和中断优先级；</p><pre class=" language-language-c"><code class="language-language-c">void ADC_NVIC_Config(void){  NVIC_InitTypeDef NVIC_InitStructure;// 优先级分组NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);  // 配置中断优先级 NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  NVIC_Init(&NVIC_InitStructure);}</code></pre><p><strong>4)</strong> 中断服务函数</p><pre class=" language-language-c"><code class="language-language-c">void ADC1_2_IRQHandler(void){if (ADC_GetITStatus(ADC1,ADC_IT_EOC)==SET) {// 读取ADC的转换值ADC_ConvertedValue = ADC_GetConversionValue(ADC1);        // ADC_ConvertedValue为转换值，定义原型为：__IO uint16_t ADC_ConvertedValue;}ADC_ClearITPendingBit(ADC1,ADC_IT_EOC);}</code></pre><p><strong>5)</strong> main()函数</p><pre class=" language-language-c"><code class="language-language-c">extern __IO uint16_t ADC_ConvertedValue;// 局部变量，用于保存转换计算后的电压值  float ADC_ConvertedValueLocal;   int main(void){    // 默认已经完成了串口配置USART_Config();ADCx_GPIO_Config();ADCx_Mode_Config();ADC_NVIC_Config();printf("\t\n ----这是一个串口发送实验----\r\n");    ADC_ConvertedValueLocal =(float) ADC_ConvertedValue/4096*3.3;     printf("\r\n The current AD value = 0x%04X \r\n",ADC_ConvertedValue);     printf("\r\n The current AD value = %f V \r\n",ADC_ConvertedValueLocal);     printf("\r\n\r\n");}</code></pre><h3 id="独立模式多通道">独立模式多通道</h3><p>因为与单通道大多配置都相同，因此只列出差异部分。</p><p>**1) **初始 ADC 用到的 GPIO；</p><pre class=" language-language-c"><code class="language-language-c">GPIO_InitStructure.GPIO_Pin = ADC_PIN1 | ADC_PIN2 | ADC_PIN3 | ADC_PIN4 | ADC_PIN5 | ADC_PIN6;</code></pre><p><strong>2)</strong> 设置 ADC 的工作参数并初始化，还需要对DMA进行配置；</p><pre class=" language-language-c"><code class="language-language-c">DMA_InitTypeDef DMA_InitStructure;RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);// 打开 DMA 时钟DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)(&(ADC_x->DR));// 外设基址为：ADC 数据寄存器地址DMA_InitStructure.DMA_MemoryBaseAddr = (u32)ADC_ConvertedValue;// 存储器地址,用户自定义变量（数组名）DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;// 数据源来自外设DMA_InitStructure.DMA_BufferSize = 6;// 缓冲区大小，应该等于数据目的地的数目大小DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;// 外设寄存器只有一个，地址不用递增DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; // 存储器地址递增// 外设数据大小为半字，即两个字节DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; // 内存数据大小也为半字，跟外设数据大小相同DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;// 循环传输模式// DMA 传输通道优先级为高，当使用一个DMA通道时，优先级设置不影响DMA_InitStructure.DMA_Priority = DMA_Priority_High;// 禁止存储器到存储器模式，因为是从外设到存储器DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;DMA_Init(DMA1_Channel1, &DMA_InitStructure);// 初始化DMADMA_Cmd(DMA1_Channel1 , ENABLE);// 使能 DMA 通道/* -------------------------------------------------------------------------------------------------------*/ADC_InitStructure.ADC_ScanConvMode = ENABLE;// 扫描模式 多通道ADC_InitStructure.ADC_NbrOfChannel = 6;// 转换通道个数// 配置ADC 通道的转换顺序和采样时间ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 2, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 3, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 4, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 5, ADC_SampleTime_55Cycles5);ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 6, ADC_SampleTime_55Cycles5);ADC_DMACmd(ADC1, ENABLE);// 使能ADC DMA 请求</code></pre><p><strong>3)</strong> main()函数</p><pre class=" language-language-c"><code class="language-language-c">// ADC1转换的电压值通过DMA方式传到SRAMextern __IO uint16_t ADC_ConvertedValue[6];// 局部变量，用于保存转换计算后的电压值  float ADC_ConvertedValueLocal[6];         int main(void){    // 默认已经完成了串口配置USART_Config();ADCx_GPIO_Config();ADCx_Mode_Config();;printf("\t\n ----这是一个串口发送实验----\r\n");    ADC_ConvertedValueLocal[0] =(float) ADC_ConvertedValue[0]/4096*3.3;    ADC_ConvertedValueLocal[1] =(float) ADC_ConvertedValue[1]/4096*3.3;    ADC_ConvertedValueLocal[2] =(float) ADC_ConvertedValue[2]/4096*3.3;    ADC_ConvertedValueLocal[3] =(float) ADC_ConvertedValue[3]/4096*3.3;    ADC_ConvertedValueLocal[4] =(float) ADC_ConvertedValue[4]/4096*3.3;    ADC_ConvertedValueLocal[5] =(float) ADC_ConvertedValue[5]/4096*3.3;    printf("\r\n CH0 value = %f V \r\n",ADC_ConvertedValueLocal[0]);    printf("\r\n CH1 value = %f V \r\n",ADC_ConvertedValueLocal[1]);    printf("\r\n CH2 value = %f V \r\n",ADC_ConvertedValueLocal[2]);    printf("\r\n CH3 value = %f V \r\n",ADC_ConvertedValueLocal[3]);    printf("\r\n CH4 value = %f V \r\n",ADC_ConvertedValueLocal[4]);    printf("\r\n CH5 value = %f V \r\n",ADC_ConvertedValueLocal[5]);    printf("\r\n\r\n");}</code></pre><h3 id="双ADC同步规则">双ADC同步规则</h3><p>**1) **初始 ADC 用到的 GPIO；</p><pre class=" language-language-c"><code class="language-language-c">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</code></pre><p><strong>2)</strong> 设置 ADC 的工作参数并初始化，还需要对DMA进行配置；</p><pre class=" language-language-C"><code class="language-language-C">ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;// 双ADC的规则同步ADC_InitStructure.ADC_ScanConvMode = ENABLE ; // 扫描模式ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;// 连续转换模式// 不用外部触发转换，软件开启即可ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;// 转换结果右对齐ADC_InitStructure.ADC_NbrOfChannel = 1;       // 转换通道个数ADC_Init(ADCx_1, &ADC_InitStructure);// 初始化ADCRCC_ADCCLKConfig(RCC_PCLK2_Div8); // 配置ADC时钟PCLK2的8分频，即9MHz// 配置ADC1 通道的转换顺序和采样时间ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5);ADC_DMACmd(ADC1, ENABLE);// 使能ADC DMA 请求// 由于没有采用外部触发，所以使用软件触发ADC转换 ADC_SoftwareStartConvCmd(ADCx_1, ENABLE);ADC_Init(ADC2, &ADC_InitStructure);// 配置ADC2 通道的转换顺序和采样时间ADC_RegularChannelConfig(ADC2, ADC_Channel_14, 1, ADC_SampleTime_239Cycles5);  ADC_ExternalTrigConvCmd(ADC2, ENABLE);// 使能ADC2的外部触发转换</code></pre><p><strong>3)</strong> main()函数</p><pre class=" language-language-c"><code class="language-language-c">// ADC1转换的电压值通过MDA方式传到SRAMextern __IO uint32_t ADC_ConvertedValue[1];// 局部变量，用于保存转换计算后的电压值  float ADC_ConvertedValueLocal[NOFCHANEL*2];        int main(void){uint16_t temp0=0 ,temp1=0;USART_Config();// 默认已经完成了串口配置ADCx_GPIO_Config();// GPIO 初始化ADCx_Mode_Config();// ADC 初始化printf("\r\n ----这是一个双ADC规则同步采集实验----\r\n");    // 取出ADC1数据寄存器的高16位，这个是ADC2的转换数据temp0 = (ADC_ConvertedValue[0]&0XFFFF0000) >> 16;    // 取出ADC1数据寄存器的低16位，这个是ADC1的转换数据    temp1 = (ADC_ConvertedValue[0]&0XFFFF);    ADC_ConvertedValueLocal[0] =(float) temp0/4096*3.3;    ADC_ConvertedValueLocal[1] =(float) temp1/4096*3.3;    printf("\r\n ADCx_1 value = %f V \r\n", ADC_ConvertedValueLocal[1]);    printf("\r\n ADCx_2 value = %f V \r\n", ADC_ConvertedValueLocal[0]);    printf("\r\n\r\n");}}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10子系统Ubuntu使用经验</title>
      <link href="/win10-ubuntu.html"/>
      <url>/win10-ubuntu.html</url>
      
        <content type="html"><![CDATA[<h2 id="Win10-子系统-Ubuntu-安装-Apache2-错误">Win10 子系统 Ubuntu 安装 Apache2 错误</h2><p>安装好 Apache2 后，通过命令<code>service apache2 start </code>启动，报错为：</p><pre class=" language-language-shell"><code class="language-language-shell">AH00076: Failed to enable APR_TCP_DEFER_ACCEPT</code></pre><p>解决办法在 stackoverflow 上有，方法如下：</p><p><code>sudo vi</code> 打开 <code>/etc/apache2/apache2.conf</code>，在文件的最底部加上一行以下内容：</p><pre><code>AcceptFilter http none</code></pre><p>然后重启 Apache2 问题解决。</p><p>常用指令：</p><pre class=" language-language-shell"><code class="language-language-shell">update-rc.d apache2 defaults</code></pre><p>将apache2服务添加到自动启动程序组。</p><h2 id="通过源代码安装软件">通过源代码安装软件</h2><ul><li><p>使用压缩包管理工具解压缩软件包</p></li><li><p>进入到解压缩文件所在的目录</p></li><li><p>执行指令：</p><pre class=" language-language-shell"><code class="language-language-shell">./configuremakeinstall</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10子系统Ubuntu下配置Jupyter Notebook并实现内网穿透</title>
      <link href="/jupyter.html"/>
      <url>/jupyter.html</url>
      
        <content type="html"><![CDATA[<p>之前看到有朋友在服务器上，搭建了<a href="https://jupyter.org/" target="_blank" rel="noopener">Jupyter Notebook</a>（一个笔记本，支持多种编程语言），觉得挺好的，自己也想弄个用用，无奈没有服务器，只好另寻他径。</p><h2 id="启用Win10子系统">启用Win10子系统</h2><p>网络上有很多教程，就不赘述了:</p><ul><li><a href="%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%90%AF%E7%94%A8Win10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F">手把手教你启用Win10的Linux子系统</a></li><li><a href="https://www.jianshu.com/p/c3025989c28c" target="_blank" rel="noopener">Win10上体验Linux子系统–Linux虚拟机的完美替代方案</a></li></ul><h2 id="安装Jupyter-Notebook">安装Jupyter Notebook</h2><a id="more"></a><h3 id="安装">安装</h3><p>在子系统中选择用python来安装jupyter，因为Ubuntu自带了python3</p><ol><li><p>将pip升级到最新版本</p><pre class=" language-language-python"><code class="language-language-python">pip3 install --upgrade pip</code></pre></li><li><p>安装Jupyter Notebook</p><pre><code>pip3 install jupyter</code></pre></li></ol><h3 id="配置">配置</h3><p>配置的过程中如有疑问，请查阅官方文档，命令如下：</p><pre class=" language-language-shell"><code class="language-language-shell">jupyter notebook --help</code></pre><h4 id="默认端口启动">默认端口启动</h4><p>安装完成后，在终端输入命令：</p><pre class=" language-language-shell"><code class="language-language-shell">jupyter notebook</code></pre><p>执行命令后，在终端中会有一些提示信息：</p><pre class=" language-language-shell"><code class="language-language-shell">[I 00:09:44.222 NotebookApp] Serving notebooks from local directory: /home/mahoo12138[I 00:09:44.223 NotebookApp] The Jupyter Notebook is running at:[I 00:09:44.224 NotebookApp] http://localhost:8888/[I 00:09:44.225 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).</code></pre><ul><li>注意：之后在Jupyter Notebook的所有操作，都请保持终端<strong>不要关闭</strong>，因为一旦关闭终端，就会断开与本地服务器的链接，jupyter notebook也就关闭了。</li><li>此时在浏览器中打开**<code>http://localhost:8888</code>**，即可看到jupyter notebook</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials%5Cjupyter%5Clocalhost.png" alt=""></p><h4 id="指定端口启动">指定端口启动</h4><p>如果你想指定端口启动，可输入以下命令：</p><pre class=" language-language-shell"><code class="language-language-shell">jupyter notebook --port <port_number></code></pre><h4 id="修改配置文件">修改配置文件</h4><ul><li><p>终端修改</p><ul><li><p>生成配置文件</p><pre class=" language-language-shell"><code class="language-language-shell">jupyter notebook --generate-config</code></pre></li><li><p>生成密码</p><pre class=" language-language-shell"><code class="language-language-shell">jupyter notebook password</code></pre><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials%5Cjupyter%5Cpassword.png" alt=""></p></li></ul></li><li><p>文件修改</p><ul><li>Win10子系统Ubuntu的目录在<em>C:\Users\用户名\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home</em></li></ul><p>在<strong>home</strong>中打开<em>Ubuntu用户名</em> \ .jupyter\jupyter_notebook_config.py文件，如果你准备远程访问，可以定位到<em>c.NotebookApp.allow_remote_access</em>，删除**#<strong>，修改值为</strong>True**</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials%5Cjupyter%5Callow_amote_access.png" alt=""></p></li></ul><h2 id="远程访问Jupyter-Notebook">远程访问Jupyter Notebook</h2><h3 id="内网穿透">内网穿透</h3><p>由于是在本地搭建的jupyter Notebook，在外网上是访问不了的，如果想远程访问的话，需要内网穿透，这里推荐使用**<a href="https://natapp.cn/" target="_blank" rel="noopener">NATAPPP</a>**，注册后会有两条免费的隧道使用，配置如图：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials%5Cjupyter%5Cnatapp.png" alt=""></p><ul><li><p>之后下载客户端：<a href="https://natapp.cn/#download" target="_blank" rel="noopener">直达链接</a></p></li><li><p>打开客户端，输入<em>natapp -authtoken=(之前复制的字符)</em>，回车</p><pre><code>natapp -authtoken=255bf538d7b773f6</code></pre><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials%5Cjupyter%5Cnatapp_ok.png" alt=""></p></li></ul><p>图中的地址就是外网访问地址了，当然要保持Ubuntu子系统客户端和Natapp客户端同时运行，jupyter notebook才能打开，还有一个体验极差的设置，免费的内网穿透隧道会不定时更换地址，如果真的需要长时间运行，付费版才是王道。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jupyter Notebook </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘点C语言中你不知道的小细节</title>
      <link href="/c-c-2.html"/>
      <url>/c-c-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="0UL-1UL">0UL/1UL</h2><p><strong>0UL 表示 无符号长整型 0<br>1UL 表示 无符号长整型 1</strong></p><p>一般的 <strong>1</strong> 没有后缀，系统默认指定的类型为<code>int</code>，即有符号的整型数。</p><p>除此之外还可以将<code>l</code>，<code>u</code>自由组合形成多种后缀（不区分大小写），单独添加也没问题，例如：<mark>2u，3lu，4Lu</mark>。</p><p>主要的作用，我只在keil编译中遇到过，在宏定义中将<code>1 &lt;&lt; 16</code>这类操作，默认的是有符号的，需要将 1 改成 1ul 无符号长整型。</p><p>参考自：<a href="https://blog.csdn.net/qq1987924/article/details/11369063" target="_blank" rel="noopener">c语言中的0UL或1UL是什么意思</a></p><h2 id="volatile">volatile</h2><p>首先我们来看volatile在维基百科中的一些简介，有个大概的了解：</p><blockquote><p>在程序设计中，尤其是在C语言、C++、C#和Java语言中，使用volatile关键字声明的变量或对象通常具有与优化、多线程相关的特殊属性。通常，<strong>volatile</strong>关键字用来阻止（伪）编译器认为的无法“被代码本身”改变的代码（变量/对象）进行优化。如在C语言中，<strong>volatile</strong>关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</p></blockquote><p>当用volatile声明变量时，则表示该变量随时可能发生变化，避免因为编译器对代码优化导致读脏数据，例如</p><pre class=" language-language-c"><code class="language-language-c">static int a;void main(){    a = 0;while (a != 255);}</code></pre><p>一个执行优化的编译器会提示没有代码能修改<code>a</code>的值，并假设它永远都只会是<code>0</code>。因此编译器将用类似==while (true);==的无限循环替换函数体；但是<code>a</code>可能指向一个随时都能被计算机系统其他部分修改的地址，例如CPU的硬件寄存器， 上面的代码永远检测不到这样的修改。如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字：</p><pre class=" language-language-c"><code class="language-language-c">static volatile int a;</code></pre><p>这样修改以后循环条件就不会被优化掉，当值改变的时候系统将会检测到。</p><h3 id="参考自：Volatile变量">参考自：<a href="https://zh.wikipedia.org/zh-hans/Volatile%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">Volatile变量</a></h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的SysTick定时器初体验</title>
      <link href="/stm32-3.html"/>
      <url>/stm32-3.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="SysTick介绍">SysTick介绍</h2><p>SysTick 属于CM3内核的外设，它可以产生非常精确的延时，一般用于操作系统，用于产生一个单独的时钟节拍，相当于操作系统的心脏。</p><p>SysTick是一个24bit的向下递减的计数器，计数器每计数一次的时间为$1 \over SYSCLK$，Stm32中一般设置系统时钟为72M。当重载数值寄存器递减到0时，系统定时器则会产生中断。</p><p>SysTick—系统定时器有 4 个寄存器，一般配置时，大多操作前三个。</p><table><thead><tr><th style="text-align:center">寄存器名称</th><th style="text-align:center">寄存器描述</th></tr></thead><tbody><tr><td style="text-align:center">CTRL</td><td style="text-align:center">SysTick 控制及状态寄存器</td></tr><tr><td style="text-align:center">LOAD</td><td style="text-align:center">SysTick 重装载数值寄存器</td></tr><tr><td style="text-align:center">VAL</td><td style="text-align:center">SysTick 当前数值寄存器</td></tr><tr><td style="text-align:center">CALIB</td><td style="text-align:center">SysTick 校准数值寄存器</td></tr></tbody></table><ul><li><p><font size="4"><strong>CTRL</strong></font></p><table><thead><tr><th style="text-align:center">位段</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">复位值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">16</td><td style="text-align:center">COUNTFLAG</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td style="text-align:left">如果在上次读取本寄存器后， SysTick 已经计到了 0，则该位为 1。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLKSOURCE</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td style="text-align:left">时钟源选择位，0=AHB/8，1=处理器时钟 AHB</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">TICKINT</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td style="text-align:left">1=SysTick 倒数计数到 0 时产生 SysTick 异常请<br>求，0=数到 0 时无动作。也可以通过读取<br>COUNTFLAG 标志位来确定计数器是否递减到0。</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">ENABLE</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td style="text-align:left">SysTick 定时器的使能位</td></tr></tbody></table></li><li><p><font size="4"><strong>LOAD</strong></font></p><table><thead><tr><th style="text-align:center">位段</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">复位值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">23:0</td><td style="text-align:center">RELOAD</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td>当倒数计数至零时，将被重装载的值</td></tr></tbody></table></li><li><p><font size="4"><strong>VAL</strong></font></p><table><thead><tr><th style="text-align:center">位段</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">复位值</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">23:0</td><td style="text-align:center">CURRENT</td><td style="text-align:center">R/W</td><td style="text-align:center">0</td><td>读取时返回当前倒计数的值，写它则使之清零，<br>同时还会清除在 SysTick 控制及状态寄存器中的 COUNTFLAG 标志。</td></tr></tbody></table></li></ul><h2 id="代码分析">代码分析</h2><pre class=" language-language-c"><code class="language-language-c">static __INLINE uint32_t SysTick_Config(uint32_t ticks){   if (ticks > SysTick_LOAD_RELOAD_Msk)  /* 重装载值判断 */      return (1);             SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;       /* 设置重装载寄存器 */  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);   /* 设置中断优先级 __NVIC_PRIO_BITS为4 */  SysTick->VAL   = 0;                                           /* 设置当前数值寄存器 */  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | /* 设置系统定时器的时钟源为 AHBCLK=72M */                   SysTick_CTRL_TICKINT_Msk   | /* 使能系统定时器中断 */                   SysTick_CTRL_ENABLE_Msk;                     /* 使能定时器 */  return (0);                                                 }</code></pre><p>固件库编程时，我们通过<code>SysTick_Config()</code>配置系统定时器，形参 ticks 用来设置重装载寄存器的值，最大不能超过重装载寄存器的值$2^{24}$，固件库中的宏定义提供了我们参考值：</p><pre class=" language-language-c"><code class="language-language-c">#define SYSCLK_FREQ_72MHz  72000000uint32_t SystemCoreClock = SYSCLK_FREQ_72MHz;SysTick_Config(SystemFrequency / 1000);    //1ms中断一次SysTick_Config(SystemFrequency / 100000); //10us中断一次SysTick_Config(SystemFrequency / 1000000); //1us中断一次</code></pre><h2 id="延时函数设计">延时函数设计</h2><ul><li>无中断函数类型延时</li></ul><pre class=" language-language-c"><code class="language-language-c"> //微秒级延时 void Systick_Delay_us(uint32_t us){ uint32_t i; SysTick_Config(SystemFrequency / 1000000);//1us中断一次 for (i = 0; i<us;i++){ while(!((SysTick->CTRL)&(1<<16)));//读取16位COUNTFLAG，定时器一个中断周期1us结束while循环 }  SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//关闭SysTick定时器 }  //毫秒级延时void Systick_Delay_ms(uint32_t ms){ uint32_t i; SysTick_Config(SystemFrequency / 1000);//1us中断一次 for (i = 0; i<us;i++){ while(!((SysTick->CTRL)&(1<<16)));//读取16位COUNTFLAG，定时器一个中断周期1ms结束while循环 }  SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;//关闭SysTick定时器 } </code></pre><ul><li>含中断函数类型延时</li></ul><pre class=" language-language-c"><code class="language-language-c">//固件库宏定义#define__IOvolatile/*!< defines 'read / write' permissions   */static __IO uint32_t TimingDelay;void Delay_us(__IO uint32_t nTime){ TimingDelay = nTime;   SysTick->CTRL |=  SysTick_CTRL_ENABLE_Msk;// 使能SysTick定时器  while(TimingDelay != 0);}  void SysTick_Init(void){  if (SysTick_Config(SystemCoreClock / 1000)){ //1ms中断一次,计数周期为1ms  while (1);//防止定时器配置错误产生一些未知的连锁的错误  } }  void TimingDelay_Decrement(void){if (TimingDelay != 0x00){//判断是否计时结束  TimingDelay--;  }}</code></pre><pre class=" language-language-c"><code class="language-language-c">//文件stm32f10x_it.c内void SysTick_Handler(void){  TimingDelay_Decrement();</code></pre><blockquote><p>有关<strong>volatile</strong>的细节可参考我的这篇博文：<a href="">盘点C语言中你不知道的小细节</a>，技术尚浅，仅供参考</p></blockquote><p>需要延时的时候，我们可以调用函数<code>Delay_us()</code>并传入具体的参数， 当然之前还需要对SysTick进行初始化，将参数传给全局变量<code>TimingDelay</code>，当一个计数递减周期完成，产生异常（中断），自动调用中断服务函数<code>SysTick_Handler(void)</code>，这个函数我们可以在文件<mark>stm32f10x_it.c</mark>中编程，再声明一个函数用于控制多少个计时周期，每完成一个计时周期减一，直至延时完成。</p><p>延时实例：</p><pre class=" language-language-c"><code class="language-language-c">void main(){    SysTick_Init();//计时器初始化    Delay_us(1000);//延时1000ms，1s    {}//用户代码}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客SEO优化指南</title>
      <link href="/hexo-seo.html"/>
      <url>/hexo-seo.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装sitemap">安装sitemap</h2><ol><li>Windows环境下直接在博客根目录打开<code>Git Bash</code>，运行命令：</li></ol><pre class=" language-language-shell"><code class="language-language-shell">  npm install hexo-generator-sitemap --save   # sitemap.xml提交给谷歌搜素引擎  npm install hexo-generator-baidu-sitemap --save   # baidusitemap.xml提交百度搜索引擎</code></pre><ol start="2"><li>在站点配置文件<code>_config.yml</code>中添加以下代码：</li></ol><pre><code>Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap:    path: baidusitemap.xmlsitemap:    path: sitemap.xml</code></pre><ol start="3"><li><p>修改站点配置文件<code>_config.yml</code>，添加<code>url</code>，其次就是Hexo文章默认的链接是<code>:year/:month/:day/:title/</code>这样的链接对SEO十分不友好，所以应改成<code>title.html</code>格式：</p><pre class=" language-language-shell"><code class="language-language-shell"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://mahoo12138.github.iopermalink: :title.htmlpermalink_defaults:</code></pre></li><li><p>Hexo编译，提交站长平台</p><p><code>Hexo g &amp;&amp; hexo d</code>后会在/public目录下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，这就是站点地图。 之后就可以提交到各大站长平台了。</p></li></ol><h2 id="添加关键词">添加关键词</h2><h3 id="站点关键词">站点关键词</h3><p>在博客根目录下找到<code>_config.yml</code>文件，在所示地方添加<code>keywords: 关键字1,关键字2,关键字3…</code>，采用<code>英文逗号</code>隔开，注意<code>keywords</code>与<code>关键词</code>之间的<code>空格</code>。</p><pre><code>title: Mahoo Blogsubtitle: 记录技术成长的每一瞬间description: 一切的恐惧都来源于无知！keywords: 老黄博客,Mahoo Blog,Stm32,Mahoo,Mahoo12138author: Mahoo Huanglanguage: zh-CN</code></pre><h3 id="文章关键词">文章关键词</h3><p>打开主题路径内的<code>head.ejs</code>文件，不同主题所在路径和文件都可能不同，Next主题是 <code>head.swig</code>，我的主题是<code>head.ejs</code>，添加如下代码：</p><pre class=" language-language-html"><code class="language-language-html"># next theme   head.swig{% if page.keywords %}  <meta name="keywords" content="{{ page.keywords }}">{% elif page.tags and page.tags.length %}  <meta name="keywords" content="{% for tag in page.tags %}{{ tag.name }},{% endfor %}">{% elif theme.keywords %}  <meta name="keywords" content="{{ theme.keywords }}">{% endif %}# matery themehead.ejs <% if (page.keywords){ %>    <meta name="keywords" content="<%- page.keywords %>" /> <% } else if (theme.keywords){ %>    <meta name="keywords" content="<%- theme.keywords %>" /></code></pre><p>添加上述代码后，主要是检测文章内是否有关键词，之后还要在<code>\scaffolds\post.md</code>中 添加：</p><pre><code>keywords: </code></pre><p>就可以在新写的文件里添加keyword，格式为[keyword1,keyword2,keyword3] 。</p><h2 id="配置robots-txt">配置robots.txt</h2><blockquote><p><strong>robots.txt</strong>（统一小写）是一种存放于<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%AB%99" target="_blank" rel="noopener">网站</a>根目录下的<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a>编码的<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文本文件</a>，它通常告诉网络<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">搜索引擎</a>的漫游器（又称<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E8%9C%98%E8%9B%9B" target="_blank" rel="noopener">网络蜘蛛</a>），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">元数据</a>（Metadata，又称元资料） 。</p></blockquote><p>简单来说，它就是网站和爬虫之间的协议，规定了哪些文件可以访问，哪些文件禁止访问。</p><p>在博客根目录下的<code>source</code>新建<code>robots.txt</code>写入：</p><pre><code>User-agent: *Allow: /Allow: /home/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Sitemap: http://lansus.coding.me/sitemap.xmlSitemap: http://lansus.coding.me/baidusitemap.xml</code></pre><p>在编译后这个文件会出现在<code>blog/public</code>中 ，控制的就是该目录下的文件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记C语言中的宏定义及条件编译</title>
      <link href="/c-c-4.html"/>
      <url>/c-c-4.html</url>
      
        <content type="html"><![CDATA[<h2 id="普通宏定义">普通宏定义</h2><pre class=" language-language-c"><code class="language-language-c">#define PI 3.14#define a (1+2)//添加括号使语义表达更清楚printf("%s:%d","PI",PI);//引号中的宏定义不会被替换，输出：PI:3.14#undef PI//取消PI的宏定义#define 1111 F//报错，宏定义起始位不能为数字#define word "apple//宏定义中引号必须成对出现#define char ‘a</code></pre><h2 id="带参数的宏定义">带参数的宏定义</h2><pre class=" language-language-c"><code class="language-language-c">#define MAX(a,b)(a>b ? a:b)#define MIN(a,b)(a<b ? a:b)int main(){    int sum = MAX(1,2) + MIN(2,3);    return 0;}</code></pre><p>当宏定义需要多行的代码时，可以用<code>\</code>来连接：</p><pre class=" language-language-c"><code class="language-language-c">#define SWAP(a,b)   {\    int t = 0;  \    t = a;  \    a = b;  \    b = t;  \}int main(){    int x = 2,y = 3;    SWAP(x,y);    printf("%d,%d",x,y);    return 0;}</code></pre><h2 id="宏定义中的特殊符号">宏定义中的特殊符号</h2><pre class=" language-language-c"><code class="language-language-c">#define TOSTRING(a)#a#define CONNECT(a,b)a##bint main(){    char *str0 = TOSTRING(hello);    char *str1 = CONNECT("hello","world");}</code></pre><h2 id="宏定义实现条件编译">宏定义实现条件编译</h2><h3 id="基本用法"><strong>基本用法</strong></h3><p>条件编译的控制与<code>if-else</code>语句相似，只不过控制的是是否将其后的代码段进行编译。</p><pre class=" language-language-c"><code class="language-language-c">#if (判断条件){code}#else    {code}#endif</code></pre><pre class=" language-language-c"><code class="language-language-c">#if (判断条件1){code}#elif (判断条件2)    {code}#else    {code}#endif</code></pre><h3 id="其他用法">其他用法</h3><p><code>if define</code>等价于<code>ifdef</code>，<code>ifndef</code>等价于<code>if !define()</code>：</p><pre class=" language-language-c"><code class="language-language-c">#if defined(PI)  //  如果前面已经定义过PI这个宏，就将code编译进去。    {code}#endif#if defined(PI)  //  如果前面没有定义过PI这个宏，就将code编译进去。    {code}#endif</code></pre><h3 id="防止头文件重复引入">防止头文件重复引入</h3><pre class=" language-language-c"><code class="language-language-c">#ifndef _HEADER//_HEADER为自定义的名称#define _HEADER/*头文件其余内容*/#endif</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的中断优先级及中断编程</title>
      <link href="/stm32-2.html"/>
      <url>/stm32-2.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="中断优先级">中断优先级</h2><p>在STM32中，由内核外设<code>NVIC（嵌套向量中断控制器）</code>控制着整个芯片中断的相关功能，在NVIC中有一个<code>IPR寄存器</code>用来配置外部中断的优先级，宽度为8bit，在F103只使用了高4bit。</p><p>优先级分组由另一个内核外设<code>SCB（系统控制块）</code>的<code>AIRCR（应用程序中断及复位寄存器）</code>的PRIGROUP的[10:8]位决定，</p><table><thead><tr><th style="text-align:center">组</th><th style="text-align:center">AIRCR</th><th style="text-align:center">分配情况[7:4]</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">111</td><td style="text-align:center">0 : 4</td><td style="text-align:center">抢占优先级0位，4位响应优先级</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">110</td><td style="text-align:center">1 : 3</td><td style="text-align:center">抢占优先级1位，3位响应优先级</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">101</td><td style="text-align:center">2 : 2</td><td style="text-align:center">抢占优先级2位，2位响应优先级</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">100</td><td style="text-align:center">3 : 1</td><td style="text-align:center">抢占优先级3位，1位响应优先级</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">011</td><td style="text-align:center">4 : 0</td><td style="text-align:center">抢占优先级4位，0位响应优先级</td></tr></tbody></table><p>从上表来看，当设置为组3时，每个中断优先寄存器的高四位中，前高三位为抢占优先级，低一位是响应优先级。即可设置抢占优先级别为0~7，响应优先级别为1/0。</p><p>当然，抢占优先级是高于响应优先级的，数值越小所代表的优先级也越高；抢占优先级顾名思义为级别高的优先级可以打断级别低的，而抢占优先级相同的情况下，响应优先级高的，则先响应，但是不能打断低的响应优先级，响应表现的是响应的速度。</p><p>当两个优先级都相同的时候，这时候就根据中断向量表中编号判断优先级。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/it_list.png" alt="it_list"></p><h2 id="中断例程">中断例程</h2><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/interupt.png" alt="原理图"></p><p>例程规划的是设置KEY1，KEY2为外部中断，当触发中断后，中断服务函数将两个LED的状态反转，</p><h3 id="初始化GPIO">初始化GPIO</h3><p>首先将LED所在的GPIO初始化，具体操作封装在函数<code>LED_GPIO_Config()</code>内：</p><pre class=" language-language-c"><code class="language-language-c">/*定义一个GPIO_InitTypeDef类型的结构体*/GPIO_InitTypeDef GPIO_InitStructure;/*开启LED相关的GPIO外设时钟*/RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK | LED3_GPIO_CLK, ENABLE);/*选择要控制的GPIO引脚*/GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;/*设置引脚模式为通用推挽输出*/GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   /*设置引脚速率为50MHz */   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; /*调用库函数，初始化GPIO*/GPIO_Init(GPIOB, &GPIO_InitStructure);/*选择要控制的GPIO引脚*/GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;/*调用库函数，初始化GPIO*/GPIO_Init(GPIOB, &GPIO_InitStructure);/*选择要控制的GPIO引脚*/GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;/*调用库函数，初始化GPIOF*/GPIO_Init(GPIOB, &GPIO_InitStructure);/* 关闭所有led灯*/GPIO_SetBits(GPIOB, GPIO_Pin_5);GPIO_SetBits(GPIOB, GPIO_Pin_0); GPIO_SetBits(GPIOB, GPIO_Pin_1);</code></pre><h3 id="初始化EXTI">初始化EXTI</h3><p>具体的操作都封装在函数<code>EXTI_Key_Config()</code>内：</p><pre class=" language-language-c"><code class="language-language-c">GPIO_InitTypeDef GPIO_InitStructure; EXTI_InitTypeDef EXTI_InitStructure;/*开启按键GPIO口的时钟*/RCC_APB2PeriphClockCmd((RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO),ENABLE);/* 配置 NVIC 中断*/NVIC_Configuration();/*--------------------------KEY1配置-----------------------------*//* 选择按键用到的GPIO */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;/* 配置为浮空输入 */GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;GPIO_Init(GPIOA, &GPIO_InitStructure);/* 选择EXTI的信号源 */GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); EXTI_InitStructure.EXTI_Line = EXTI_Line0;/* EXTI为中断模式 */EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;/* 上升沿中断 */EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;/* 使能中断 */EXTI_InitStructure.EXTI_LineCmd = ENABLE;EXTI_Init(&EXTI_InitStructure);/*--------------------------KEY2配置-----------------------------*//* 选择按键用到的GPIO */GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;/* 配置为浮空输入 */GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;GPIO_Init(GPIOC, &GPIO_InitStructure);/* 选择EXTI的信号源 */GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13); EXTI_InitStructure.EXTI_Line = EXTI_Line13;/* EXTI为中断模式 */EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;/* 下降沿中断 */EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;/* 使能中断 */EXTI_InitStructure.EXTI_LineCmd = ENABLE;EXTI_Init(&EXTI_InitStructure);</code></pre><h4 id="配置NVTI中断">配置NVTI中断</h4><p><mark>NVIC_Configuration()</mark></p><pre class=" language-language-c"><code class="language-language-c">NVIC_InitTypeDef NVIC_InitStructure;  /* 配置NVIC为优先级组1 */NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);  /* 配置中断源：按键1 */NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;/* 配置抢占优先级 */NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;/* 配置子优先级 */NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;/* 使能中断通道 */NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;NVIC_Init(&NVIC_InitStructure);  /* 配置中断源：按键2，其他使用上面相关配置 */  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;NVIC_Init(&NVIC_InitStructure);</code></pre><h3 id="中断服务函数">中断服务函数</h3><p>上述初始化操作完成后，则在文件<code>stm32f10x_it.c</code>中编写中断服务函数了，编写中断服务函数，要对应其中断信号源，例如按键key1的中断源为<code>EXTI0_IRQn</code>，对应的中断服务函数则为<code>EXTI0_IRQHandler</code>。</p><pre class=" language-language-c"><code class="language-language-c">/* 定义控制IO的宏 */#define digitalToggle(p,i) {p->ODR ^=i;} //输出反转状态#define LED1_TOGGLE digitalToggle(GPIOB,GPIO_Pin_5)#define LED2_TOGGLE digitalToggle(GPIOB,GPIO_Pin_0)void EXTI0_IRQHandler(void){  //确保是否产生了EXTI Line中断if(EXTI_GetITStatus(EXTI_Line0) != RESET){// LED1 取反LED1_TOGGLE;    //清除中断标志位EXTI_ClearITPendingBit(EXTI_Line0);     }  }void EXTI15_10_IRQHandler(void){  //确保是否产生了EXTI Line中断if(EXTI_GetITStatus(EXTI_Line13) != RESET){// LED2 取反LED2_TOGGLE;    //清除中断标志位EXTI_ClearITPendingBit(EXTI_Line13);     }  }</code></pre><h3 id="main-函数">main()函数</h3><pre class=" language-language-c"><code class="language-language-c">int main(void){/* LED 端口初始化 */LED_GPIO_Config();  /* 初始化EXTI中断，按下按键会触发中断，  *  触发中断会进入stm32f4xx_it.c文件中的函数*  EXTI0_IRQHandler和EXTI15_10_IRQHandler，处理中断，反转LED灯。*/EXTI_Key_Config(); /* 等待中断，由于使用中断方式，CPU不用轮询按键 */while(1){        }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解STM32的八种输入输出模式</title>
      <link href="/stm32-1.html"/>
      <url>/stm32-1.html</url>
      
        <content type="html"><![CDATA[<p>注：本文属博主学习时所作笔记，内容源大参考于野火的《零死角玩转STM32F103》以及部分网络资料，笔记内容仅作为自己参考，免去频繁查询参考手册的麻烦，如有错误，还请指出！</p><h2 id="输入模式">输入模式</h2><ul><li><p><strong>上拉输入（GPIO_Mode_IPU）</strong></p><p>上拉即把电位提高，也就是在信号进入芯片后加上一个上拉电阻，将不确定的信号锁在高电位，同时电阻还起到了限流的作用。</p></li><li><p><strong>下拉输入（GPIO_Mode_IPD）</strong></p></li></ul><p>下拉同理</p><ul><li><p><strong>模拟输入（GPIO_Mode_AIN）</strong></p><p>信号进入后不经过上拉电阻或者下拉电阻，关闭施密特触发器，经由另一线路把电压信号传送到片上外设模块。</p></li><li><p><strong>浮空输入（GPIO_Mode_IN_FLOATING）</strong></p></li></ul><p>信号进入芯片内部后，既没有接上拉电阻也没有接下拉电阻，经由触发器输入。</p><p>配置成这个模式后，用电压变量引脚电压为1点几伏，<strong>这是个不确定值</strong>，完全由外部的输入决定，一般接按键的时候用的是这个模式。由于其输入阻抗比较大，一般也可以把这种模式用于标准的通讯协议，比如IIC、USART等。  如果在该引脚悬空（在无信号输入）的情况下，读取该端口的电平是不确定的。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/GPIO.png" alt=""></p><h2 id="输出模式">输出模式</h2><ul><li><p><strong>普通推挽输出（GPIO_Mode_Out_PP）</strong></p><p>推挽输出模式下，通过配置<code>位设置/清除寄存器</code>或者输出数据寄存器的值，途经P-MOS管和N-MOS管，最终输出到I/O端口。这里要注意P-MOS管和N-MOS管，</p><p>当设置输出的值为高电平的时候，P-MOS管处于开启状态，N-MOS管处于关闭状态，此时I/O端口的电平就由P-MOS管决定：高电平；</p><p>当设置输出的值为低电平的时候，P-MOS管处于关闭状态，N-MOS管处于开启状态，此时I/O端口的电平就由N-MOS管决定：低电平。</p><p><u>同时，I/O端口的电平也可以通过输入电路进行读取；注意，此时I/O端口的电平一定是输出的电平。</u></p></li><li><p><strong>复用推挽输出（GPIO_Mode_AF_PP）</strong></p></li></ul><p>推挽复用输出模式，与推挽输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。</p><ul><li><p><strong>普通开漏输出（GPIO_Mode_Out_OD）</strong></p><p>开漏输出模式下，通过配置<code>位设置/清除寄存器</code>或者输出数据寄存器的值，途经N-MOS管，最终输出到I/O端口。这里要注意N-MOS管，当设置输出的值为高电平的时候，N-MOS管处于关闭状态，此时I/O端口的电平就不会由输出的高低电平决定，而是由I/O端口外部的上拉或者下拉决定；当设置输出的值为低电平的时候，N-MOS管处于开启状态，此时I/O端口的电平就是低电平。同时，I/O端口的电平也可以通过输入电路进行读取；注意，I/O端口的电平不一定是输出的电平。</p></li><li><p><strong>复用开漏输出（GPIO_Mode_AF_OD）</strong></p></li></ul><p>开漏复用输出模式，与开漏输出模式很是类似。只是输出的高低电平的来源，不是让CPU直接写输出数据寄存器，取而代之利用片上外设模块的复用功能输出来决定的。</p><h2 id="难点分析">难点分析</h2><ul><li><p>推挽结构和推挽电路</p><p>推挽结构一般是指<strong>两个参数相同的三极管或MOS管分别受两互补信号的控制，总是在一个三极管或MOS管导通的时候另一个截止。高低电平由输出电平决定。</strong></p><p>推挽电路是两个参数相同的三极管或MOSFET，以推挽方式存在于电路中，各负责正负半周的波形放大任务。电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。</p></li><li><p>开漏输出和推挽输出的区别</p></li></ul><ul><li><strong>开漏输出：只可以输出强低电平，高电平得靠外部电阻拉高。输出端相当于三极管的集电极。适合于做电流型的驱动，其吸收电流的能力相对强(一般20ma以内)；</strong></li><li><strong>推挽输出:可以输出强高、低电平，连接数字器件。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/STM32/Push-Pull.png" alt=""></p><p>该图中左边的便是推挽输出模式，其中比较器输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当比较器输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平。右边的则可以理解为开漏输出形式，需要接上拉。</p><ul><li>STM32中选用怎样选择I/O模式</li><li>浮空输入IN_FLOATING ——浮空输入，可以做KEY识别，RX1_</li><li>带上拉输入IPU——IO内部上拉电阻输入</li><li>带下拉输入IPD—— IO内部下拉电阻输入</li><li>模拟输入AIN ——应用ADC模拟输入，或者低功耗下省电</li><li>开漏输出OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能</li><li>推挽输出OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的</li><li>复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL、SDA）</li><li>复用功能的开漏输出_AF_OD——片内外设功能（TX1、MOSI、MISO.SCK.SS）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于汇编语言的一点点学习笔记</title>
      <link href="/asm.html"/>
      <url>/asm.html</url>
      
        <content type="html"><![CDATA[<p>汇编语言的主体是汇编指令。</p><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。</p><p>汇编指令是机器指令的助记符，便于程序员更好的操作。</p><h3 id="汇编语言的组成">汇编语言的组成</h3><ul><li>汇编指令（机器码的助记符）</li><li>伪指令（由编译器执行）</li><li>其他符号（由编译器识别）</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++再学习之基础语法</title>
      <link href="/c-c-3.html"/>
      <url>/c-c-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="define宏定义">#define宏定义</h2><pre class=" language-language-c++"><code class="language-language-c++">#include <iostream>void fun1(){#define a 10    ;}void fun2(){    int b = a;}int main() {    std::cout <<"hello world";    return 0;}</code></pre><p>上述代码并不会报错，C++是支持在函数内宏定义，并且全局可以使用，这是因为<code>#define</code>是在预编译阶段处理的，相当于直接的<strong>文本替换</strong>。</p><p>而在fun_1函数内卸载宏定义，则会出现报错了：</p><pre class=" language-language-c++"><code class="language-language-c++">void fun1(){#define a 10#undef a    ;}</code></pre><h2 id="引用">引用</h2><p>引用，可以看作是一个已定义变量的别名，也就是相当于两个变量指向同一个内存地址。</p><pre class=" language-language-c++"><code class="language-language-c++">int a = 1;int &b = a;std::cout << a << " " << b;//1 1std::cout << &a << " " << &b;//0x61fe14 0x61fe14</code></pre><p>当给任意一个变量赋值时，另一个也会随之改变。</p><pre class=" language-language-c++"><code class="language-language-c++">b = 0;std::cout << "a=" << a;//a=0a = 1;std::cout << "b=" << b;//b=1</code></pre><p>还有一个需要注意的是，普通引用必须要初始化。</p><pre class=" language-language-c++"><code class="language-language-c++">int a = 0;int &b;//error</code></pre><p>关于引用的作用，我们可以看一个c++老师必说的例子：</p><pre class=" language-language-c++"><code class="language-language-c++">//function swap two numbersvoid NumSwap(int a,int b){    int c = 0;    c = a;    a = b;    b = c;}</code></pre><p>当然，这个函数并不能完成所期望的功能，通常的做法是将参数换为指针：</p><pre class=" language-language-c++"><code class="language-language-c++">//function swap two numbers by using pointervoid NumSwap(int *a,int *b){    int c = 0;    c = *a;    *a = *b;    *b = c;}//calling the functionint a = 1,b = 2;NumSwap(&a,&b);</code></pre><p>而用引用的话也是相当的便捷的：</p><pre class=" language-language-c++"><code class="language-language-c++">//function swap two numbers by using referencevoid NumSwap(int &a,int &b){    int c = 0;    c = a;    a = b;    b = c;}//calling the functionint x = 1,y = 2;NumSwap(x,y);</code></pre><p>因为<strong>引用作函数参数时不需要初始化</strong>，这里其实是相当于进行了<code>int &amp;a =x; int &amp;b = y;</code>的操作，函数里的a，b则是x， y的引用。</p><ul><li><p>引用的本质</p><p>在C++中的内部实现是一个常指针，即<code>Type &amp;name</code>等价于<code>Type *const name</code>，</p><p>C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占内存大小与指针相同。</p><p>当引用作为参数时，实际上编译器帮助我们为实参取了地址。</p></li><li><p>引用作为返回值</p></li></ul><h2 id="static关键字">static关键字</h2><p>static定义的类成员，会被这个类创建的所有对象共享。且静态变量在类内声明后需要在外部进行定义初始化。</p><p>静态成员函数同样会被这个类创建的所有对象共享，注意<strong>在静态成员函数内不能调用非静态的变量和函数</strong>，且没有<code>this操作</code>。</p><pre class=" language-language-c++"><code class="language-language-c++">class A{    static int num;//定义静态成员public:    void Add(){        num++;    };    void ShowNum(){      std::cout<<num<<std::endl;    };    static void GetNum(){//声明静态成员函数       std::cout<<num<<std::endl;    }};int A::num = 0;//初始化静态成员int main() {    A a,b;    a.ShowNum();    a.Add();    b.ShowNum();    std::cout << a.GetNum() << std::endl;//对象调用静态成员函数    std::cout << A::GetNum();//类调用静态成员函数    return 0;}//0  1 1 1</code></pre><h3 id="继承中的static">继承中的static</h3><ul><li>基类中的静态成员变量，将被所有派生类共享</li><li>static定义的变量仍然遵循派生类的访问控制</li></ul><h2 id="C-类的模型">C++类的模型</h2><pre class=" language-language-c++"><code class="language-language-c++">#include "iostream"class C1{public:int i;  //4int j;  //4int k;  //4}; class C2{public:int i;int j;int k;static int m; public:int getK() const { return k; } void setK(int val) { k = val; }  }; struct S1{int i;int j;int k;}; struct S2{int i;int j;int k;static int m;}; int main(){std::cout<<sizeof(C1);std::cout<<sizeof(C2);    std::cout<<sizeof(S1);    std::cout<<sizeof(S2);    return 0;}</code></pre><p>首先上面三个输出都是12，我们可以得出：</p><ul><li><p>C++类中的成员函数和成员变量是分开存储的</p><ul><li>普通的成员变量存储在对象中，与struct结构体有相同的内存布局和字节对齐方式</li><li>静态成员变量存储在全局数据区</li><li>成员函数则存储在代码段中</li></ul></li><li><p>C++编译器对普通成员函数的内部处理</p><pre class=" language-language-c++"><code class="language-language-c++">class Test{private:    int m;public:    Test(int i){        m = i;    }    int getM(){        return m;    }    static void Print(){        std::cout<<"Test";    }}Test a(10);a.getM();Test::Print();</code></pre><pre class=" language-language-c++"><code class="language-language-c++">struct Test{    int m;}void Test_initialize(Test *pThis,int i){    pThis -> m = i;}int Test_getM(Test *pThis){    return pThis -> m;}void Test_Print(){    std::cout<<"Test";}Test a;Test_initialize(&a,10);Test_getM(&a);Test_Print();</code></pre></li></ul><p>对比上述两段代码我们可以发现C++类的模型是基于结构体的，  面向对象本质还是面向过程的，成员变量与成员函数之间通过<code>this指针</code>连接起来，而静态函数没有该指针。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Cloud Studio为博客搭建免费图床</title>
      <link href="/tutorial-2.html"/>
      <url>/tutorial-2.html</url>
      
        <content type="html"><![CDATA[<p>搭建的静态博客利用Markdown码字，必然少不了图片，所以需要另外的图床作为辅助，网上有很多优秀的图床程序，不过大多都功能复杂，而且图片放在别人那，让我总感觉不是很放心（万一哪天就跑路了呢？），而自己来搭建图床程序的话，需要自备服务器或者是虚拟主机，这个可是要付费的，毕竟自己的博客都是利用免费的Pages服务搭建的，而再为了托管图片去付费就有些得不偿失了，所以我想了半天，折腾了半天，可以利用腾讯云旗下的Cloud Studio的WebIDE及代码托管平台来搭建图床，步骤如下：</p><h2 id="使用Git创建本地存储库">使用Git创建本地存储库</h2><p>搭建的图床是利用Git及远程存储库的模式进行传输和存储的，我主要是在Windows平台上使用，而Win10是没有预装Git的，所以首先需要安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>；</p><ul><li><p>在你想要存储图片的路径，创建一个文件夹，例如我的<code>D:\Mahoo\Pictures\Blog</code>;</p></li><li><p>创建本地存储库（以<code>Blog</code>目录为例）</p><p>在<code>Blog</code>目录下，右击选择<code>Git Bash</code></p><pre class=" language-language-shell"><code class="language-language-shell">git init</code></pre></li></ul><p>在此文件夹内，可创建多个文件夹存储你的不同图片。</p><h2 id="使用Cloud-Studio创建远程存储库">使用Cloud Studio创建远程存储库</h2><ul><li><p>创建账号</p><p>腾讯云开发者平台：<a href="https://dev.tencent.com/" target="_blank" rel="noopener"> https://dev.tencent.com/ </a></p></li><li><p>新建一个项目</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pic_cs/new.png" alt="新建项目"></p><p>项目名称，地址自定义，是否公开勾选。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pic_cs/new1.png" alt="新建项目"></p></li></ul><p>进入新建项目界面，打开右侧<code>代码 -&gt;代码浏览 </code>，复制该项目的HTTPS地址。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pic_cs/new2.png" alt="项目界面"></p><h2 id="连接本地存储库和远程存储库">连接本地存储库和远程存储库</h2><p>当你往本地存储库添加图片后，使用指令：</p><pre class=" language-language-shell"><code class="language-language-shell">git add .git commit -m "自定义内容"git remote add origin 刚才复制的的HTTPS地址git push origin master</code></pre><p>这样的话，图片已经同步到远程存储库了，当然你对<code>git</code>相当熟悉的话，以上全是废话，此教程仅针对刚搭建博客的小白。</p><h2 id="开启Pages服务绑定域名">开启Pages服务绑定域名</h2><p>打开此界面，按提示绑定域名即可</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pic_cs/pages.png" alt=""></p><h2 id="通过直链引用图片">通过直链引用图片</h2><p>这里我举例来说明比较好懂，在写博客的过程中，当你引入一张图片时，例如是这样的：</p><pre class=" language-language-shell"><code class="language-language-shell">D:\Mahoo\Pictures\Blog\test.png</code></pre><p>这时该图片的本地地址，在已经开启Pages服务并且绑定域名的情况下，你绑定的域名直接指向了git本地存储库的根目录，也就是<code>Blog</code>，所以则可以将本地地址改成网络直链：</p><pre class=" language-language-shell"><code class="language-language-shell">http://你的域名/test.png</code></pre><p>你可以通过文本编辑器的替换功能，也可以用代码：</p><pre class=" language-language-python"><code class="language-language-python">import ref = open('D:/Mahoo/BLog/source/_posts/Cloud_studio.md', 'r', encoding="utf-8")string = f.read()f.close()key = r'D:\\Mahoo\\Pictures\\Blog\\hexo_images\\Tutorials\\pic_cs\\'new = 'https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pic_cs/'# result = re.compile(key).findall(string)# print(result)string = re.sub(key, new, string)# print(string)f = open('D:/Mahoo/BLog/source/_posts/Cloud_studio.md', 'w', encoding="utf-8")f.write(string)f.close()</code></pre><p>一个文件的链接替换当然是编辑器的替换方便的多，但如果需要替换域名，对所有博客文章进行替换时，文本编辑器就显得有些力不从心了，这里也贴出来我的代码：</p><pre class=" language-language-python"><code class="language-language-python">for files in os.walk('D:/Mahoo/BLog/source/_posts/'):    print(files[2][0])for i in range(len(files[2])):    f = open('D:/Mahoo/BLog/source/_posts/' + files[2][i], 'r', encoding="utf-8")    string = f.read()    f.close()    key = 'http://airlife.club/'#旧域名    new = 'https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/'#新域名    string = re.sub(key, new, string)    f = open('D:/Mahoo/BLog/source/_posts/' + files[2][i], 'w', encoding="utf-8")    f.write(string)    f.close()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 免费图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之串口通信</title>
      <link href="/51mcu-2.html"/>
      <url>/51mcu-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2><h3 id="通信知识">通信知识</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1.png" alt="通信分类"></p><ul><li>串行通信：数据字节一位一位在一条传输线上逐个传输；</li><li>并行通信：多位数据字节同时传输，控制简单，传输速度快。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E5%B9%B6%E8%A1%8C%E4%BC%A0%E8%BE%93%E5%92%8C%E4%B8%B2%E8%A1%8C%E4%BC%A0%E8%BE%93.png" alt=""></p><ul><li><p>异步通信：是指通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程。为使双方的收发协调，要求发送和接受设备的时钟尽可能一致。  <img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%97%B6%E9%92%9F.png" alt="异步通信时钟"></p><p>异步通信是以字符（构成的帧）为单位进行传输，字符与字符之间的间隙（时间间隔）是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间不一定有“位间隔”的整数倍的关系，但同一字符内的各位之间的距离均为“位间隔”的整数倍。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E5%AD%97%E7%AC%A6%E5%B8%A7.png" alt="字符帧"></p><p>异步通信的特点：不要求收发双方时钟的严格一致，实现容易，设备开销较小，但每个字符要附加2～3位用于起止位，各帧之间还有间隔，因此传输效率不高。</p></li><li><p>同步通信 ： 同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步可以通过两种方法实现。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" alt="左为字符同步，右为位同步"></p></li></ul><h4 id="串行通信的传输方向">串行通信的传输方向</h4><ul><li>单工：指数据传输仅能沿一个方向，不能实现反向传输；</li><li>半双工：指数据传输可以沿2个方向，但需要分时进行；</li><li>全双工：指数据可以同时双向传输。</li></ul><h4 id="信号的调制和解调">信号的调制和解调</h4><p>简单来说，调制就是利用调制器把数字信号转换成模拟信号，然后送到通信线路上去；而解调则是通过解调器把通信线路上收到的模拟信号转换成数字信号。</p><h4 id="串行通信的错误校验">串行通信的错误校验</h4><h5 id="奇偶校验">奇偶校验</h5><p>在发送数据时，数据位的最后一位为<strong>奇偶校验位</strong>（1或0）。奇校验时，数据中“1”的个数与校验位“1”的个数之和应为奇数；偶校验时，数据中“1”的个数与校验位“1”的个数之和则为偶数；</p><p>接受字符时，对“1”的个数进行校验，如发现不一致，则说明数据传输过程中出现了差错。</p><h5 id="代码和校验">代码和校验</h5><p>代码和校验是发送方将所发数据块求和（或各字节异或），产生1个字节的校验字符（校验和）附加到数据块末尾。接收方接收数据，同时对比数据块（除校验字节外）求和（或各字节异或），将所得的结果与发送方的“校验和”进行比较，相符，则无差错；否则，即在传输过程中出现了差错。</p><h5 id="循环冗余校验">循环冗余校验</h5><p>循环冗余校验通过某种数学运算，实现有效信息与校验位之间的循环校验，常用于对磁盘信息的传输，存储区的完整性校验等。这种校验方法纠错能力强，广泛应用于同步通信。</p><h4 id="传输速率与传输距离的关系">传输速率与传输距离的关系</h4><p>传输速率分为两种，即<strong>比特率</strong>和<strong>波特率</strong>：</p><ul><li><p>比特率：每秒传输二级制代码的位数；</p></li><li><p>波特率：每秒调制信号变化的次数，即每秒发送的符号数（码元）；</p><p>举个简单的例子，例如一串数据<code>01010101</code>，若比特率是8b/s（每秒传输8位），假设这串数据经过调制，我们认定每两个比特作为一个符号（码元），那么每秒传输了4个符号（码元），波特率即为4波特；</p></li><li><p>只有基带传输的比特率和波特率是相同的；</p></li><li><p>传输距离随着传输速率的增加而减小。</p></li></ul><h3 id="51串行口">51串行口</h3><h4 id="串行口结构">串行口结构</h4><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3%E7%BB%93%E6%9E%84.png" alt="串口结构"></p><p>该结构中有两个物理上独立的接收、发送缓冲器SBUF属于特殊功能寄存器，可同时发送、接收数据。它们占用同一地址（99H）；接收器是双缓冲结构；发送缓冲器，因为发送时CPU是主动的，不会产生重叠错误。</p><h4 id="状态寄存器">状态寄存器</h4><ul><li><p>工作发生寄存器 SCON</p><table><thead><tr><th style="text-align:center">位</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center">SM0</td><td style="text-align:center">SM1</td><td style="text-align:center">SM2</td><td style="text-align:center">REN</td><td style="text-align:center">TB8</td><td style="text-align:center">RB8</td><td style="text-align:center">TI</td><td style="text-align:center">RI</td></tr></tbody></table><ul><li>RI： 接收中断标志位。在方式0时，当串行接收第8位数据结束时，或在其它方式，串行接收停止位的中间时，由内部硬件使RI置1，向CPU发中断申请。也必须在中断服务程序中，用软件将其清0，取消此中断申请。</li><li>TI： 发送中断标志位。在方式0时，当串行发送第8位数据结束时，或在其它方式，串行发送停止位的开始时，由内部硬件使TI置1，向CPU发中断申请。在中断服务程序中，必须用软件将其清0，取消此中断申请。</li><li>TB8： 在方式2或方式3中，是发送数据的第九位，可以用软件规定其作用。可以用作数据的奇偶校验位，或在多机通信中，作为地址帧/数据帧的标志位。 在方式0和方式1中，该位未用。</li><li>RB8： 在方式2或方式3中，是接收到数据的第九位，作为奇偶校验位或地址帧/数据帧的标志位。在方式1时，若SM2=0，则RB8是接收到的停止位。</li><li>REN： 允许串行接收位。由软件置REN=1，则启动串行口接收数据；若软件置REN=0，则禁止接收。</li></ul><p>SM0和SM1为工作方式选择位，可选择四种工作方式：</p><table><thead><tr><th style="text-align:center">SM0</th><th style="text-align:center">SM1</th><th style="text-align:center">方式</th><th style="text-align:center">说明</th><th style="text-align:center">波特率</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">移位寄存器</td><td style="text-align:center">$f_{osc}/12$<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">10位异步收发器（8位数据）</td><td style="text-align:center">可变</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">11位异步收发器（9位数据）</td><td style="text-align:center">$f_{osc}/64$或$f_{osc}/12$</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">11位异步收发器（9位数据）</td><td style="text-align:center">可变</td></tr></tbody></table><ul><li><p>SM2：多级通信控制位。 主要用于方式2和方式3。当接收机的SM2=1时可以利用收到的RB8来控制是否激活RI（RB8＝0时不激活RI，收到的信息丢弃；RB8＝1时收到的数据进入SBUF，并激活RI，进而在中断服务中将数据从SBUF读走）。当SM2=0时，不论收到的RB8为0和1，均可以使收到的数据进入SBUF，并激活RI（即此时RB8不具有控制RI激活的功能）。通过控制SM2，可以实现多机通信。</p><p>在方式0时，SM2必须是0。在方式1时，如果SM2=1，则只有接收到有效停止位时，RI才置1。</p><p>当SM2 = 0，不论接收到的第九位是0还是1，都接受数据，产生中断；</p><p>当SM2 = 1，只有接受的第九位为1时，才接受数据，并产生中断；而如果接受到的第九位为0时，则将接收到的数据丢弃，不会产生中断。</p></li></ul></li><li><p>工作方式寄存器 PCON</p><p>PCON中只有一位SMOD与串行口工作有关：</p><p>|  位  |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |<br>| :–: | :–: | :–: | :–: | :–: | :–: | :–: | :–: | :–: |<br>| 功能 | SMOD |  -   |  -   |  -   |  -   |  -   |  -   |  -   |</p><p>PCON是没有位寻址的，也就是说不能直接操作SMOD，要直接操作PCON寄存器。</p><blockquote><p>对字节地址中的位地址进行寻址的寻址方式称为位寻址。</p></blockquote><p>SMOD为波特率倍增位：（在串口方式1，2，3时，波特率与SMOD有关）</p><ul><li>当SMOD = 1，波特率增加一倍；反之，不加倍</li><li>复位时，SMOD = 0</li></ul></li></ul><h4 id="串行口的工作方式">串行口的工作方式</h4><ol><li><p>方式0</p><p>方式0时，串行口为<strong>同步移位寄存器</strong>的输入输出方式。主要用于扩展并行输入或输出口。数据由RXD（P3.0）引脚输入或输出，同步移位脉冲由TXD（P3.1）引脚输出。发送和接收均为8位数据，<u>低位在先，高位在后</u>。波特率固定为$f_{osc}/12$。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F0_%E8%BE%93%E5%87%BA.png" alt="输出"></p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F0_%E8%BE%93%E5%85%A5.png" alt="输入"></p></li><li><p>方式1</p><p>方式1是10位数据的异步通信口。TXD为数据发送引脚，RXD为数据接收引脚，传送一帧数据的格式如图所示。其中1位起始位，8位数据位，1位停止位。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F1.png" alt="方式1"></p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F1_%E8%BE%93%E5%87%BA.png" alt="输出"></p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F1_%E8%BE%93%E5%85%A5.png" alt="输入"></p><p>用软件置REN为1时，接收器以所选择波特率的16倍速率采样RXD引脚电平，检测到RXD引脚输入电平发生负跳变时，则说明起始位有效，将其移入输入移位寄存器，并开始接收这一帧信息的其余位。接收过程中，数据从输入移位寄存器右边移入，起始位移至输入移位寄存器最左边时，控制电路进行最后一次移位。当RI=0，且SM2=0（或接收到的停止位为1）时，将接收到的9位数据的前8位数据装入接收SBUF，第9位（停止位）进入RB8，并置RI=1，向CPU请求中断。</p></li><li><p>方式2和方式3</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F2%E5%92%8C%E6%96%B9%E5%BC%8F3.png" alt="方式2和方式3"></p></li></ol><p>方式2和方式3时起始位1位，数据9位（含1位附加的第9位，发送时为SCON中的TB8，接收时为RB8），停止位1位，一帧数据为11位。方式2的波特率固定为晶振频率的1/64或1/32，方式3的波特率由定时器T1的溢出率决定。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F2%E5%92%8C%E6%96%B9%E5%BC%8F3_%E8%BE%93%E5%87%BA.png" alt="输出"></p><p>发送开始时，先把起始位0输出到TXD引脚，然后发送移位寄存器的输出位（D0）到TXD引脚。每一个移位脉冲都使输出移位寄存器的各位右移一位，并由TXD引脚输出。 第一次移位时，停止位“1”移入输出移位寄存器的第9位上 ，以后每次移位，左边都移入0。当停止位移至输出位时，左边其余位全为0，检测电路检测到这一条件时，使控制电路进行最后一次移位，并置TI=1，向CPU请求中断。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E4%B8%B2%E5%8F%A3_%E6%96%B9%E5%BC%8F2%E5%92%8C%E6%96%B9%E5%BC%8F3_%E8%BE%93%E5%85%A5.png" alt="输入"></p><p>接收时，数据从右边移入输入移位寄存器，在起始位0移到最左边时，控制电路进行最后一次移位。当RI=0，且SM2=0（或接收到的第9位数据为1）时，接收到的数据装入接收缓冲器SBUF和RB8（接收数据的第9位），置RI=1，向CPU请求中断。如果条件不满足，则数据丢失，且不置位RI，继续搜索RXD引脚的负跳变。</p><h4 id="波特率的计算">波特率的计算</h4><p>在串行通信中，收发双方对发送或接收数据的速率要有约定。 通过软件可对单片机串行口编程为四种工作方式，其中方式0和方式2的波特率是固定的，而方式1和方式3的波特率是可变的， <strong>由定时器T1的溢出率来决定</strong>。</p><p>串行口的四种工作方式对应三种波特率。由于输入的移位时钟的来源不同，所以，各种方式的波特率计算公式也不相同。</p><ul><li><p>方式0的波特率 = $f_{osc}/12$</p></li><li><p>方式2的波特率 =$(2^{SMOD}/64)· f_{osc}$</p></li><li><p>方式1的波特率 =$(2^{SMOD}/32)·(T1溢出率)$</p></li><li><p>方式3的波特率 =$(2^{SMOD}/32)·(T1溢出率)$</p></li></ul><p>当T1作为波特率发生器时，最典型的用法是使T1工作在自动重装的8位定时器方式（即方式2，且TCON的TR1=1，以启动定时器）。这时溢出率取决于TH1中的计数值。 T1 溢出率 = $f_{osc} /{12×(256 －X)} $，X为定时器的初值。在单片机的应用中，常用的晶振频率为：12MHz和11.0592MHz。所以，选用的波特率也相对固定。常用的串行口波特率以及各参数的关系如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E6%B3%A2%E7%89%B9%E7%8E%87%E5%92%8CT1.png" alt="常用波特率与定时器T1的参数关系"></p><h4 id="串口的操作步骤">串口的操作步骤</h4><p>串行口工作之前，应对其进行初始化，主要是设置产生波特率的定时器T1、串行口控制和中断控制。</p><ol><li>设置波特率<ul><li>确定定时器T1的工作方式（设置TMOD寄存器）</li><li>给计数器赋初值（工作方式2会自动重装）（设置TH1，TL1）</li></ul></li><li>设置串口工作方式<ul><li>设置SCON寄存器</li><li>打开中断</li><li>打开定时器T1（设置TR1），开始产生波特率</li></ul></li></ol><p>示例程序：</p><pre class=" language-language-c"><code class="language-language-c">void UsartConfiguration(){    SCON = 0X50;//设置工作方式为1    TMOD = 0X20;//设置计数器工作方式2    PCON = 0X80;//SMOD = 1,波特率加倍    TH1 = 0XF3;//计数器初始值设置，波特率为4.8Kb/s    TL1 = 0XF3;    ES = 1;//打开接收中断    EA = 1;//打开总中断    TR1 = 1;//打开计数器}</code></pre><h2 id="程序代码">程序代码</h2><p>以下代码将实现将PC发出的数据传送到单片机中，单片机再将收到的数据发送到PC上显示（在串口助手上显示）</p><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>void UsartConfiguration(){    SCON = 0X50;//设置工作方式为1    TMOD = 0X20;//设置计数器工作方式2    PCON = 0X00;//SMOD = 0,波特率加倍    TH1 = 0Xfd;//计数器初始值设置，波特率为4.8Kb/s    TL1 = 0Xfd;    ES = 1;//打开接收中断    EA = 1;//打开总中断    TR1 = 1;//打开计数器}void main(){    UsartConfiguration();    while(1);}void uart() interrupt 4{    unsigned char _data;        _data = SBUF;//取出接收到的数据    RI = 0;//清除接收中断标志位SBUF = _data;//将接受的数据    while(!TI);//等待数据传输完成    TI = 0;//清除发送中断标志位}</code></pre><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>frequency oscillate，在单片机中指的是晶振频率，而晶振频率有内部和外部之分。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之中断系统</title>
      <link href="/51mcu-5.html"/>
      <url>/51mcu-5.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念基础">概念基础</h2><h3 id="font-size-5-什么是中断-font"><strong><font size="5">什么是中断</font></strong></h3><p>当你正在看动漫时，突然手机来电话了，你暂停动漫，去接电话，在接电话的时候，又有人敲门，你暂时放下电话，去开门。我们可以把看动漫当作在执行主程序，那么电话就是<strong>中断源</strong>，电话铃响了就是<strong>中断请求</strong>，暂停动漫即是<strong>现场保护</strong>，接电话就是<strong>中断响应</strong>，有敲门声就是<strong>更高一级的中断请求</strong>，去开门则是<strong>中断嵌套</strong>，把门打开继续接电话就是<strong>中断返回</strong>，电话OK后继续看动漫则是<strong>现场恢复</strong>。</p><p>内核与外设之间的主要交互方式有两种<font color="red">轮询</font>和<font color="red">中断</font>，轮询工作效率极低，而且不具有响应紧急事件的功能；<u>中断系统则使内核具备了应对突发事件的能力。</u></p><p>中断既然可以处理紧急事件，也就是不知道中断什么时候发生，所以每个中断都需要一个中断入口地址，即为<strong>中断向量</strong>，这样的话，无论中断什么时候发生，它都有一个确定的程序执行初始点。中断响应之后，执行的那段程序称之为<strong>中断服务函数</strong>，顾名思义它是专门为这个中断服务的。</p><h3 id="font-size-5-51单片机的中断系统-font"><font size="5"><strong>51单片机的中断系统</strong> </font></h3><p>80C51的中断系统有5个中断源 （忽略定时/计数器2） ，2个优先级，可实现二级中断嵌套。</p><table><thead><tr><th style="text-align:center">中断源</th><th style="text-align:center">中断标志</th><th style="text-align:center">中断向量（地址）</th><th style="text-align:center">优先级</th><th style="text-align:center">序号（C语言）</th></tr></thead><tbody><tr><td style="text-align:center">外部中断0 INT0</td><td style="text-align:center">IE0</td><td style="text-align:center">0003H</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">定时/计数器0 T0</td><td style="text-align:center">TF0</td><td style="text-align:center">000BH</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">外部中断1 INT1</td><td style="text-align:center">IE1</td><td style="text-align:center">0013H</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">定时/计数器1 T1</td><td style="text-align:center">TF1</td><td style="text-align:center">001BH</td><td style="text-align:center">4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">串口中断</td><td style="text-align:center">RI/TI</td><td style="text-align:center">0023H</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/51%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F.jpg" alt="中断系统结构"></p><p>从前面的介绍我们可以知道，不管主程序执行到什么地方，只要外部中断0产生请求，内核就要响应该中断，就回到0003H这个地址去执行代码。如果使用汇编语言，则要记住每个中断源对应的地址；C语言则需要记住序号即可。</p><h3 id="font-size-5-中断控制-font"><strong><font size="5">中断控制</font></strong></h3><p>4个特殊功能寄存器来实施中断控制：</p><ul><li>中断允许寄存器 IE (Interrupt Enable )</li><li>中断优先级寄存器 IP ( Interrupt Priority )</li><li>定时/计数器及外部中断控制寄存器 TCON</li><li>串口控制寄存器 SCON</li></ul><p><strong><font size="4">中断响应条件：</font></strong></p><ul><li>中断源有中断请求</li><li>此中断源的中断允许位为1</li><li>CPU中断允许位为1</li></ul><h4 id="中断允许寄存器-IE">中断允许寄存器 IE</h4><table><thead><tr><th style="text-align:center">位序</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center">EA</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">ES</td><td style="text-align:center">ET1</td><td style="text-align:center">EX1</td><td style="text-align:center">ET0</td><td style="text-align:center">EX0</td></tr><tr><td style="text-align:center">控制位（0禁止，1允许）</td><td style="text-align:center">总开关</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">串口</td><td style="text-align:center">定时器1</td><td style="text-align:center">外部中断1</td><td style="text-align:center">定时器0</td><td style="text-align:center">外部中断0</td></tr><tr><td style="text-align:center">位地址</td><td style="text-align:center">AFH</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">ACH</td><td style="text-align:center">ABH</td><td style="text-align:center">AAH</td><td style="text-align:center">A9H</td><td style="text-align:center">A8H</td></tr></tbody></table><h4 id="中断优先级寄存器-IP">中断优先级寄存器 IP</h4><table><thead><tr><th style="text-align:center">位序</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th></th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td>-</td><td>-</td><td>-</td><td>PS</td><td>PT1</td><td>PX1</td><td>PT0</td><td>PX0</td></tr><tr><td style="text-align:center">优先级控制位（0低，1高）</td><td></td><td></td><td></td><td>串口</td><td>定时器1</td><td>外部中断1</td><td>定时器0</td><td>外部中断0</td></tr><tr><td style="text-align:center">位地址</td><td></td><td></td><td></td><td>BCH</td><td>BBH</td><td>BAH</td><td>B9H</td><td>B8H</td></tr></tbody></table><h4 id="定时-计数器的控制寄存器-TCON">定时/计数器的控制寄存器 TCON</h4><table><thead><tr><th style="text-align:center">位序</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">位名称</td><td style="text-align:center">TF1</td><td style="text-align:center">TR1</td><td style="text-align:center">TF0</td><td style="text-align:center">TR0</td><td style="text-align:center">IE0</td><td style="text-align:center">IT1</td><td style="text-align:center">IE0</td><td style="text-align:center">IT0</td></tr></tbody></table><ul><li><strong>TF1</strong>：定时/计数器T1溢出中断请求位（0：无中断请求，1：有中断请求）</li><li><strong>TR1</strong>：定时/计数器T1启动位（0：停止定时/计数器，1：启动定时/计数器）</li><li><strong>TF0</strong>：定时/计数器T0溢出中断请求位</li><li><strong>TR0</strong>：定时/计数器T0启动位</li><li><strong>IE1</strong>：外部中断1请求标志位</li><li><strong>IT1</strong>：外部中断1触发方式控制位（0：低电平触发，1：下降沿触发）</li><li><strong>IE0</strong>：外部中断0请求标志位</li><li><strong>IT0</strong>：外部中断0触发方式控制位（0：低电平触发，1：下降沿触发）</li></ul><p><strong>下降沿</strong>：</p><blockquote><p>电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。</p></blockquote><h4 id="串行口控制寄存器-SCON">串行口控制寄存器 SCON</h4><table><thead><tr><th style="text-align:center">位序</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">位名称</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">TI</td><td style="text-align:center">RI</td></tr></tbody></table><ul><li><strong>TI</strong>：串行接口发送完成中断请求标志位（ 响应中断时需手动软件清除）</li><li><strong>RI</strong>：串行接口接收完成中断请求标志位（ 响应中断时需手动软件清除）</li></ul><h3 id="一次中断的完整步骤">一次中断的完整步骤</h3><ol><li><p>中断请求</p><p>中断事件一旦发生，中断源提交中断请求（将中断标志位置为1），欲请求CPU暂停目前的工作，转向为该中断作专项服务；</p></li><li><p>中断使能</p><p>虽然中断源提交了中断请求，但是能否得到CPU的响应，还要取决于该中断请求能否通过若干的关卡送达CPU（中断使能位为1，关卡放行），关卡有两类：</p><ul><li>此中断源的中断允许位</li><li>全局中断允许位</li></ul></li><li><p>中断响应</p><p>如果一路通畅，则CPU响应该中断请求，记录断点，跳转到中断服务程序。对于INT和TMR中断，中断响应时中断标志位会被硬件自动清零。</p></li><li><p>中断处理</p><p>对中断源进行有针对性的服务；</p></li><li><p>中断返回</p><p>返回到主程序断点处，继续执行主程序；</p></li></ol><p>1，3，5由硬件自动完成，2，4由用户编程完成。中断响应条件为1，2同时满足。</p><h2 id="程序代码">程序代码</h2><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>void Delay(unsigned int ms){unsigned int i ,j;for(i = ms; i > 0; i--){for(j = 112; j>0; j--);}}void main(){P1 =   0x0f;//0000 1111EX1 = 1;    //外部中断1 INT1 打开EA =1;    //全局中断打开IT1 = 1;//设置触发方式为下降沿触发while(1);}//中断服务函数void low() interrupt 2{P1 = ~P1;Delay(200);}</code></pre><p>首先设置P1管脚连接的排灯为后四个灯亮，把各个卡点开启（如外部中断1 和 全局中断），IT1（P3.3）设置触发方式为下降沿，之后可以将引脚P3.3与P3.6（按键）连接，如此一来就可以通过按键来触发中断；</p><p>当按键按下松手时即是一个下降沿，此时会触发中断，执行中断服务函数，转变为前四个灯亮。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之定时器</title>
      <link href="/51mcu-6.html"/>
      <url>/51mcu-6.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念基础">概念基础</h2><h3 id="单片机延时基础">单片机延时基础</h3><p>之前的延时我们都使用的是利用C语言的多次的空循环进行延迟操作，这样的缺点是：CPU时间被占用无法进行其他任务，导致系统效率降低。而且延时时间越长，该缺点越明显，所以，这种延时操作只适用于短暂延时，或简单的项目。</p><p>而定时器/计数器的使用，实现了单片机对时间的有效控制。单片机中有多个定时/计数器，都可以实现定时和计数的功能。</p><h3 id="定时-计数器结构">定时/计数器结构</h3><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="定时/计数器结构"></p><p>16位寄存器T0、T1分别由TH0、TL0和TH1、TL1四个8位计数器组成 ，其中两个定时器的区别为：</p><ul><li>T0（定时器0）可分成2个独立的8位定时器，而定时器1则不能；</li><li>T1（定时器1）可作为串口的波特率发生器，而定时器0则不能。</li></ul><p>还有两个特殊功能寄存器用于控制定时/计数器：</p><ul><li>TMOD，工作方式控制寄存器，确定工作方式和功能；</li><li>TCON，工作状态控制寄存器，控制定时/计数器的启动、停止及溢出标志。</li></ul><h3 id="定时-计数器控制">定时/计数器控制</h3><h4 id="工作方式寄存器TMOD">工作方式寄存器TMOD</h4><p>低四位（0，1，2，3）用于T0，高四位用于T1：</p><table><thead><tr><th style="text-align:center">位</th><th style="text-align:center">7</th><th style="text-align:center">6</th><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th></tr></thead><tbody><tr><td style="text-align:center">功能</td><td style="text-align:center">GATE</td><td style="text-align:center">$C/\overline{T}$</td><td style="text-align:center">M1</td><td style="text-align:center">M0</td><td style="text-align:center">GATE</td><td style="text-align:center">$C/\overline{T}$</td><td style="text-align:center">M1</td><td style="text-align:center">M0</td></tr></tbody></table><ul><li><p><strong>GATE</strong>：门控位，用于控制定时器的启动是否受外部中断源的影响。当GATE = 0时，只要使用软件将TCON中的TR0或TR1置为1，就可以启动定时/计数器工作；当GATE = 0时，要用软件将TCON中的TR0或TR1为1，同时外部中断的引脚INT0/1也为高电平，才可以启动定时/计数器。即此时多了一个启动条件：INT0/1引脚需为高电平。</p></li><li><p>$C/\overline{T}$：定时/计数器模式选择位，当$C/\overline{T}=0$ 为定时模式；$C/\overline{T}= 1$为计数模式。</p></li><li><p><strong>M1/M0</strong>：工作方式设置位，定时/计数器有四种工作方式：</p><table><thead><tr><th style="text-align:center">M1M0</th><th style="text-align:center">工作方式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:center">方式0</td><td style="text-align:center">13位定时/计数器</td></tr><tr><td style="text-align:center">01</td><td style="text-align:center">方式1</td><td style="text-align:center">16位定时/计数器</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">方式2</td><td style="text-align:center">8位自动重装定时/计数器</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">方式3</td><td style="text-align:center">T0分成两个独立的定位/计数器，T1此方式停止计数</td></tr></tbody></table></li></ul><h5 id="定时-计数器工作方式">定时/计数器工作方式</h5><ul><li><p><strong>方式0：为13位定时计数器</strong>：由TL0的低5位（高3位未用）和TH0的8位组成。TL0的低5位溢出时向TH0进位，TH0溢出时，置位TCON中的TF0标志，向CPU发出中断请求。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E6%96%B9%E5%BC%8F0.png" alt="方式0"></p><p>计数个数与计数初值的关系：$X = 2^8-N$</p></li><li><p><strong>方式1：为16位定时计数器</strong>：由TL0作为低8位，TH0 作为高8位，组成了16位加1计数器 。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E6%96%B9%E5%BC%8F1.png" alt="方式1"></p><p>计数个数与计数初值的关系为：$X=2^{16}－N$</p></li><li><p><strong>方式2：8位自动重装初值定时/计数器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E6%96%B9%E5%BC%8F2.png" alt="方式2"></p><p>计数个数与计数初值的关系为：$X=2^8－N$</p></li><li><p><strong>方式3：只适用于定时/计数器T0</strong>，定时器T1处于方式3时相当于TR1=0，停止计数。</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/51mcu/%E6%96%B9%E5%BC%8F3.png" alt="方式3"></p><p>工作方式3将T0分成为两个独立的8位计数器TL0和TH0 。</p></li></ul><h4 id="工作状态寄存器TCON">工作状态寄存器TCON</h4><table><thead><tr><th style="text-align:center">位序</th><th style="text-align:center">D7</th><th style="text-align:center">D6</th><th style="text-align:center">D5</th><th style="text-align:center">D4</th><th style="text-align:center">D3</th><th style="text-align:center">D2</th><th style="text-align:center">D1</th><th style="text-align:center">D0</th></tr></thead><tbody><tr><td style="text-align:center">位名称</td><td style="text-align:center">TF1</td><td style="text-align:center">TR1</td><td style="text-align:center">TF0</td><td style="text-align:center">TR0</td><td style="text-align:center">IE1</td><td style="text-align:center">IT1</td><td style="text-align:center">IE0</td><td style="text-align:center">IT0</td></tr></tbody></table><ul><li><p>TF1：T1溢出标志位</p><p>当T1计数满溢出时，硬件将TF1置1，并申请中断。接入服务程序之后，其将自动清零；T1工作时，CPU可随时查询TF1的状态。所以，TF1可用作查询测试的标志。TF1也可以用软件置1或清0，同硬件的效果一样。</p></li><li><p>TR1：T1运行控制位</p><p>TR1 = 1：启动定时器；TR1 = 0：关闭计时器，由软件控制。</p></li><li><p>TF0：T0溢出标志位</p><p>功能同TF1，工作对象是T0。</p></li><li><p>TR0：T0运行控制位</p><p>功能同TF1，工作对象是T0。</p></li><li><p>IE1：外部中断1请求标志位</p></li><li><p>IT1：外部中断1触发方式选择位</p></li><li><p>IE0：外部中断0请求标志位</p></li><li><p>IT1：外部中断0触发方式选择位</p></li></ul><h3 id="定时-计数器原理">定时/计数器原理</h3><p>定时/计数器的实质是<strong>加1计数器</strong>，由高8位和低8位2个寄存器组成。加1计数器有两个计数脉冲来源：一是由系统的时钟振荡输出脉冲经12分频后送来；二是由T0或T1引脚输入的外部脉冲源。</p><p>每来一个脉冲，计数器加1，当加到计数器全为1的时候，再输入一个脉冲使计数器归零，且计数器的溢出时TCON中的TF0或TF1置1，向CPU发出中断请求（定时/计数器中断允许时）。</p><p>如果定时/计数器处于定时模式，则表示定时时间结束；计数模式即计数值已满。所以，溢出时计数器的值减去计数器的初值即为加1计数器的计数值。</p><p>当设置为定时器模式时，加1计数器是对内部机器周期计数（1个机器周期相当于12个震荡周期，即<strong>计数频率为晶振频率的$1/12$</strong>）。计数个数乘以机器周期$T_{cy}$就是定时时间t。</p><p>设置为计数器模式时，外部事件计数脉冲由T0或T1引脚输入到计数器。在每个机器周期的S5P2期间采样T0，T1引脚电平。当某周期采样到一高电平输入，而下一周期又采样到一低电平时，则计数器加1，更新的计数值，在下一个周期的S3P1期间装入计数器。由于检测一个从1到0的下降沿需要两个机器周期，因此要求被采样的电平至少要维持一个机器周期。当晶振频率为12MHz时，最高计数频率不超过1/2MHz，即计数脉冲的周期要大于$2\mu{s}$。</p><h4 id="CPU-时序的有关知识">CPU 时序的有关知识</h4><ul><li>S5P2： 代表第5状态中的第二节拍</li></ul><blockquote><p>机器周期：一般也叫CPU周期。 表示从内存读取一条指令字的最短时间，它是指令周期的最小单位。它等于单指令的周期长度 。 在51单片机中 一个机器周期=6状态周期=12时钟周期。</p></blockquote><blockquote><p>指令周期：一条指令包括1个或多个机器周期。所有的C语言代码最后都会编译成汇编代码来执行，而执行一条汇编指令需要的机器周期就叫做指令周期</p></blockquote><blockquote><p>状态周期：在8051单片机中把一个时钟周期定义为一个节拍（用P表示），二个节拍定义为一个状态周期（用S表示）。一个状态周期等于两个时钟周期。</p></blockquote><blockquote><p>时钟周期：又叫<strong>振荡周期</strong>， 是指为单片机提供时钟信号的振荡源的周期（ 晶振频率的倒数 ）。</p></blockquote><h3 id="定时-计数器操作">定时/计数器操作</h3><ul><li><p>步骤：</p><ol><li>选择工作方式（设置M1，M0）</li><li>选择控制方式（设置GATE）</li><li>选择模式：定时器还是计数器（设置C/T）</li><li>给定时/计数器赋初值（设置$TH_X$和$TL_x$）</li><li>开启定时器中断（设置ET0和ET1）</li><li>开启总中断（设置EA）</li><li>打开计数器（设置TR1和TR0）</li></ol></li><li><p>配置计数器：</p><pre class=" language-language-c"><code class="language-language-c">void TimerConfiguration(){    TMOD = 0X01;//定时器T0工作方式1    TH0 = 0X3c;//设置初始值    TL0 = 0X0B0;    EA = 1;//打开总中断    ET0 = 1;//打开定时器T0中断    TR0 = 1;//启动定时器T0}</code></pre></li><li><p>定时器T0初值计算（晶振为12MHz）</p><p><strong>51单片机内部时钟频率是外部时钟的12分频</strong>， 也就是说当外部晶振的频率输入到单片机里面的时候要进行12分频。比如说你用的是12MHz的晶振，那么单片机内部的时钟频率就是$12MHz\over12$ = 1MHz，当你使用12MHz的外部晶振的时候，机器周期=$1 \over1MHz$=$1\mu{s}$。</p><p>当我们需要定时50ms时，则计数值为${50ms}\over{1{\mu}s}$=50000，所以<strong>初值 = 最大值计数值 - 50000 = 15536</strong> (3cb0)，即$TH_x$ =0x3c，$TL_x$= 0xb0。</p></li></ul><h2 id="程序代码">程序代码</h2><ul><li><p>LED按定时器T0设定的时间周期闪烁</p><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>sbit led = P1 ^ 0;void t0_init(){    TMOD = 0X01;//设置定时器T0工作方式1    TH0 = 0X3c;//设置初始值    TH0 = 0Xb0;    EA = 1;//打开总中断    ET0 = 1;//打开定时器T0中断    TR0 = 1;//启动定时器T0}void main(){    led = 1;    t0_init();    while(1);}void t0() interrupt 1{    TH0 = 0X3c;//设置初始值    TL0 = 0Xb0;    led = ~led;}</code></pre></li><li><p>LED按500ms/次的精确频率闪动</p><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>sbit led = P1 ^ 0;int i = 0;void t1_init(){    TMOD = 0X10;//设置定时器T1工作方式1    TH0 = 0X3c;//设置初始值    TH0 = 0Xb0;    EA = 1;//打开总中断    ET1 = 1;//打开定时器T1中断    TR1 = 1;//启动定时器T1}void main(){    led = 1;    t1_init();    while(1){        if(i == 10){            led = ~led;            i = 0;        }    }}void t1() interrupt 3{    TH0 = 0X3c;//设置初始值    TL0 = 0Xb0;   i++;}</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之独立键盘输入</title>
      <link href="/51mcu-4.html"/>
      <url>/51mcu-4.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念基础">概念基础</h2><h3 id="上拉电阻">上拉电阻</h3><p>上拉电阻就是将一个不确定信号（高或低电平），通过一个电阻与电源VCC相连，固定在高电平，电阻同时起限流作用。下拉同理，也是将一个不确定信号（高或低电平），通过一个电阻与地GND相连，固定在低电平。上拉电阻和下拉电阻二者共同的作用是：</p><ul><li>避免电压的“悬浮”，否则会容易产生积累电荷，静电荷造成电路的不稳定；</li><li>在引脚电平不定的时候，让后面有一个稳定的电平；</li><li>提高输出引脚的驱动能力。</li></ul><h3 id="键盘防抖">键盘防抖</h3><p>当按一次按键时，由于按键有反应时间，以及抖动，造成机器感应到多次按键操作，而<strong>防抖</strong>就是让按键在抖动的过程中（一般是5-10ms）仅让机器感应到按键的一次操作。</p><p><strong>软件防抖程序思路：</strong></p><p><img src="/51mcu-4/D:%5CMahoo%5CPictures%5CBlog%5Chexo_images%5CStudy%5C51mcu%5C%E8%BD%AF%E4%BB%B6%E9%98%B2%E6%8A%96.png" alt="软件防抖程序思路"></p><h2 id="程序代码">程序代码</h2><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>sbit led0 = P1^0;sbit k1 = P3^4;void Delay(unsigned int ms){unsigned int i ,j;for(i = ms; i > 0; i--){for(j = 112; j>0; j--);}}void main(){P1 = 0xff;while(1){if(k1 == 0){//判断是否有按下按键的信号Delay(5);//延时5ms，防抖if(k1 == 0){//再次判断是否按键按下while(k1 == 1);//直到按键松开，之后后续代码led0 = ~led0;//}}}}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之数码管</title>
      <link href="/51mcu-3.html"/>
      <url>/51mcu-3.html</url>
      
        <content type="html"><![CDATA[<h2 id="段选和位选">段选和位选</h2><p>例如，你要控制四个数码管，依次是1，2，3，4，你要选择哪一个数码管（一个数码管即为一个“日”）这就是<strong>位选</strong>，顾名思义为选择位置；之后你要让选择的数码管显示某一个数字或符号，你就要控制数码管的a,b,c,d,e,f,g这七个发光二极管，让其亮或灭，这就是<strong>段选</strong>，顾名思义为选择数码管的哪一段。</p><h2 id="数据存储类型">数据存储类型</h2><ul><li><p><strong>程序存储器（code）</strong></p><p>程序存储区（64KB），<u>可直接理解为ROM</u>，只读，可由汇编操作码<code>MOVC @A DPTR</code>访问，8051系列仅执行存储在code中的程序；</p></li><li><p><strong>内部数据存储</strong></p><p>对内部数据存储器的访问是非常快的，因为使用8位地址寻址；</p><ul><li><p><strong>data</strong></p><p>可直接寻址的内部数据存储器（128字节），<u>可直接理解为内部RAM</u>，读写速度最快；</p></li><li><p><strong>idata</strong></p><p>间接可寻址内部数据存储器（256字节），其中前128字节和data的128字节完全相同，只是访问方法不一样；</p></li><li><p><strong>bdata</strong></p><p>可位寻址的内部数据存储器（<code>20h to 2Fh</code> 16字节），支持混合位和字节访问。</p></li></ul></li><li><p><strong>外部数据存储</strong></p><p>可读写，由于外部数据存储器是通过指针寄存器间接访问的，所以访问速度要比内部数据存储器慢，</p><ul><li><p><strong>xdata</strong></p><p>外部数据存储器（64KB），<u>可直接理解外部RAM</u>，可由汇编操作码<code>MOVX @DPTR</code>访问，Large Memory Model在此内存空间中定义变量；</p></li><li><p><strong>pdata</strong></p><p>分页寻址外部数据存储器，其指定外部存储器中的一页（256字节），由操作码<code>MOVX @Rn</code>访问；Compact Memory Model在此内存空间中定义变量。</p></li></ul></li></ul><h2 id="程序代码">程序代码</h2><pre class=" language-language-c"><code class="language-language-c">#include "reg52.h"#include "intrins.h"#define uint unsigned intsbit a = P2 ^ 4;sbit b = P2 ^ 5;sbit c = P2 ^ 6;sbit d = P2 ^ 7;sbit fm = P2 ^ 3;//定义数码管段选的方式unsigned char code sz[17] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};/**延迟函数*/void Delay(uint ms){uint i ,j;for(i = ms; i > 0; i--){for(j = 112; j>0; j--);}}/**位选数码管函数*/void Led(int id){switch(id){case 1:a = 1;b = 0;c = 0;d = 0;break;case 2:a = 0;b = 1;c = 0;d = 0;break;case 3:a = 0;b = 0;c = 1;d = 0;break;case 4:a = 0;b = 0;c = 0;d = 1;break;default:break;}}void main(){int i = 0;Led(1);while(1){    P1 = 0xfe;for (i = 0; i < 8; i++){Led(4 - (i%4));P0 = sz[8 - i];fm = 0;Delay(100);fm = 1;Delay(1000);P1 = _crol_(P1,1);} }}</code></pre><p>可以看看这个数组定义：</p><pre class=" language-language-c"><code class="language-language-c">unsigned char code sz[17] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};</code></pre><p>其中code是一个域修饰符，它指定该数组存储在程序存储区，写入后不可更改。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机学习之流水灯蜂鸣器</title>
      <link href="/51mcu-1.html"/>
      <url>/51mcu-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="流水灯">流水灯</h2><p>在代码中的延时均使用软件延时，即函数嵌套循环体进行延时；</p><h3 id="位输出实现">位输出实现</h3><pre class=" language-language-c"><code class="language-language-c">#include<reg52.h>#define uint unsigned int#define on 1#define off 0sbit led_0 = P1 ^ 0;sbit led_1 = P1 ^ 1;sbit led_2 = P1 ^ 2;sbit led_3 = P1 ^ 3;sbit led_4 = P1 ^ 4;sbit led_5 = P1 ^ 5;sbit led_6 = P1 ^ 6;sbit led_7 = P1 ^ 7;//延时函数void Delay(uint ms){uint i ,j;for(i = ms; i > 0; i--){for(j = 112; j>0; j--);}}void main(){while(1){led_0 = on;Delay(200);led_0 = off;                led_1 = on;        Delay(200);led_1 = off;                led_2 = on;        Delay(200);led_2 = off;                led_3 = on;        Delay(200);led_3 = off;                led_4 = on;        Delay(200);led_4 = off;                led_5 = on;        Delay(200);led_5 = off;                led_6 = on;        Delay(200);led_6 = off;                led_7 = on;        Delay(200);led_7 = off;}}</code></pre><h3 id="循环位移实现">循环位移实现</h3><pre class=" language-language-c"><code class="language-language-c">P1 = 0xfe//1111 1110while(1){    Delay(1000);    P1 = _crol_(P1,1);//将P1左移一位}</code></pre><p>_crol_()函数的使用，必须要加上<code>#include "intrins.h" </code>，引入头文件，该函数的原型为：</p><pre class=" language-language-c"><code class="language-language-c">unsigned char _crol_(unsigned char val,unsigned char n);</code></pre><p><strong>函数功能</strong>：以位形式将 <code>val</code> 左移 n 位，该函数与8051“RLA”指令相关。如果二进制数为 01010101 那么 _crol_(1) 左移1位后将高位补低位，结果10101010。</p><h3 id="移位操作实现">移位操作实现</h3><pre class=" language-language-c"><code class="language-language-c">int i = 0;while(1){    P1 = 0xfe;    for (i = 0; i < 8; i++){        Delay(1000);        P1 <<= 1;        P1 = P1 | 0X01;    }}</code></pre><p>通过每次位移一位，再与<code>0x01</code>进行或操作，这样每次都有一位是低电位，从而实现流水灯。</p><h2 id="蜂鸣器">蜂鸣器</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用的不完全填坑指南</title>
      <link href="/hexo-2.html"/>
      <url>/hexo-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="在内容里-不要与-紧挨着">在内容里 # 不要与 { 紧挨着</h2><p>例如我的问题：</p><pre><code>$\color{black}{red}$</code></pre><p>出现错误时，黑色我用的是<code>#000</code>而不是<code>black</code>，然后在执行<code>hexo g</code>会有如下报错：</p><pre class=" language-language-shell"><code class="language-language-shell">Template render error: (unknown path)  Error: expected end of comment, got end of file  ...</code></pre><p>我的解决方法很特殊，一般只在{ 与 # 之间添加一个空格即可。</p><h2 id="尽量不要将-和-连接在一起">尽量不要将<code>{和{</code>连接在一起</h2><ul><li><p>报错信息</p><pre class=" language-language-shell"><code class="language-language-shell">Template render error: (unknown path) [Line XX, Column XX]  expected variable end  ...</code></pre><p>后面还会附带文章的html代码，指出错误所在的准确位置；</p></li><li><p>报错原因</p><pre class=" language-language-markdown"><code class="language-language-markdown">机器周期=$12\times{ {1}\over{12}}MHz$=$1\mu{s}$。 </code></pre><p>经过查阅后发现， hexo 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>{ {</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。。</p></li><li><p>解决方法</p><p>我的解决方法很弱智，但是有用，<strong>在<code>{和{</code>间添加空格</strong>，OK！</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员帮我修个电脑吧之副屏教程</title>
      <link href="/pc-2.html"/>
      <url>/pc-2.html</url>
      
        <content type="html"><![CDATA[<p>因为最近一直在学习安卓，在开发过程中，需要查看开源项目的文档，笔记本的15.6的显示屏就完全不够用了，想着自己还有一块连接台式主机的显示器，就差一根VGA数据线了。</p><h2 id="连接显示器">连接显示器</h2><ul><li>闲置显示屏</li><li>VGA或HDMI等连接线</li></ul><p>连接好后，在<strong>设置-&gt;系统-&gt;显示</strong>中，设置为<code>将桌面扩展到此显示器</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pc/fp.png" alt=""></p><p>并且可以调节显示器的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pc/fp2.png" alt=""></p><h2 id="连接安卓手机">连接安卓手机</h2><p>首先主机和客户端需要在同一局域网内，其他的交给软件实现就行了，<strong>spacedesk</strong>官方下载：<a href="http://www.spacedesk.net/" target="_blank" rel="noopener">http://www.spacedesk.net/</a></p><p>网盘下载：</p><ul><li>主机：<a href="https://pan.baidu.com/s/17DU1eGAXyKC7m2RJrsFlGw" target="_blank" rel="noopener">https://pan.baidu.com/s/17DU1eGAXyKC7m2RJrsFlGw</a></li><li>客户端：<a href="https://pan.baidu.com/s/1XJxupSaaymkjzbdDPAwREw" target="_blank" rel="noopener">https://pan.baidu.com/s/1XJxupSaaymkjzbdDPAwREw</a></li></ul><p>笔记本上开启主机端后，手机客户端，打开后点击已有的主机端即可：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pc/fp3.jpg" alt="img"></p><p>最后放一张效果图：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Tutorials/pc/fp4.png" alt="1566610748861"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 副屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习及开发中的Java语法及理论学习</title>
      <link href="/android-java.html"/>
      <url>/android-java.html</url>
      
        <content type="html"><![CDATA[<h2 id="理论">理论</h2><h3 id="理解java回调机制">理解java回调机制</h3><h3 id="android开发中的同步和异步区别的理解">android开发中的同步和异步区别的理解</h3><ul><li><p>同步执行的话，就是程序会呆板地从头执行到尾，耗时间的东西不执行完，程序不会继续往下走，等待时间长的话，有时候就会造成失去响应了。</p><p>异步的好处，就是把一些东西，特别是耗时间的东西扔到后台去运行了(doInBackground)，程序可以继续做自己的事情，防止程序卡在那里失去响应。</p></li><li><p>同步是指两个线程的运行是相关的，其中一个线程要阻塞等待另外一个线程的运行。<br>异步的意思是两个线程毫无相关，自己运行自己的。</p></li><li><p>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。<br>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p></li><li><p>同步：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事<br>异步: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p></li><li><p>同步就是你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。</p><p>异步就是你叫我，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。</p></li><li><p><strong>个人理解</strong>：</p><ul><li>同步就是两个人一起工作，必须前一个人把手上的活干完，第二个人才能开始干</li><li>异步则是两个人分开各自闷声发大财，相互没影响</li></ul></li></ul><h2 id="indexOf-和-lastIndexOf">indexOf 和 lastIndexOf</h2><p>从名字上来看，二者都是索引，区别是：</p><ul><li>indexOf 是查询某个字符子串在字符串中<strong>首次</strong>出现的位置（索引值）</li><li>lastIndexOf 有四种重载：<ul><li><strong>public int lastIndexOf(int ch):</strong> 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li><strong>public int lastIndexOf(int ch, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li><strong>public int lastIndexOf(String str):</strong> 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li><strong>public int lastIndexOf(String str, int fromIndex):</strong> 返回指定字符在此字符串中最后一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li></ul></li></ul><p>实例：</p><pre class=" language-language-java"><code class="language-language-java">public class Test {    public static void main(String args[]) {        String Str = new String("mahoo12138");        String SubStr1 = new String("oo");        String SubStr2 = new String("12138");        System.out.print("查找字符 o 最后出现的位置 :" );        System.out.println(Str.lastIndexOf( 'o' ));        System.out.print("从第4个位置查找字符 o 最后出现的位置 :" );        System.out.println(Str.lastIndexOf( 'o', 4 ));        System.out.print("子字符串 SubStr1 最后出现的位置:" );        System.out.println( Str.lastIndexOf( SubStr1 ));        System.out.print("从第2个位置开始搜索子字符串 SubStr1 最后出现的位置 :" );        System.out.println( Str.lastIndexOf( SubStr1, 8 ));        System.out.print("子字符串 SubStr2 最后出现的位置 :" );        System.out.println(Str.lastIndexOf( SubStr2 ));    }}</code></pre><h2 id="System-out-println-方法和toString-方法">System.out.println()方法和toString()方法</h2><p>Object有个toString实例方法。Object类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p><pre class=" language-language-java"><code class="language-language-java">getClass().getName() '@' Integer.toHexString(hashCode())</code></pre><p>而在Java中，所有的对象都是继承自Object，因此所有的Java对象都具有<code>toString</code>方法。</p><p>但很多类都重写了Object类的<code>toString</code>方法，用于返回可以表述该对象信息的字符串。</p><p>当程序使用<code>System.out.println()</code>方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的<code>toString</code>方法返回该对象的字符串表示。</p><p>当然，空引用变量调用toString方法，会引起空指针异常。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员帮我修个电脑吧之电脑常识</title>
      <link href="/pc-1.html"/>
      <url>/pc-1.html</url>
      
        <content type="html"><![CDATA[<h2 id="显示器连接口">显示器连接口</h2><h3 id="VGA接口">VGA接口</h3><p>D型口，15空，也叫D-Sub接口；</p><p><img src="/pc-1/D:%5CMahoo%5CPictures%5CBlog%5Chexo_images%5CStudy%5Cpc%5Cvga.jpg" alt="img"></p><h3 id="DVI接口">DVI接口</h3><p>主要分为三种，DVI-A，DVI-D，DVI-I；</p><p><img src="/pc-1/C:%5CUsers%5CMahoo%5CPictures%5CBlog%5Chexo_images%5CStudy%5Cpc%5Cdvi.jpg" alt="img"></p><h3 id="HDMI接口">HDMI接口</h3><p>高清晰度多媒体接口；</p><p><img src="/pc-1/C:%5CUsers%5CMahoo%5CPictures%5CBlog%5Chexo_images%5CStudy%5Cpc%5Chdmi.jpg" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习之MD设计模式</title>
      <link href="/android-md.html"/>
      <url>/android-md.html</url>
      
        <content type="html"><![CDATA[<h2 id="添加库依赖">添加库依赖</h2><pre class=" language-language-java"><code class="language-language-java">implementation 'com.android.support:design:28.0.0'</code></pre><h2 id="Snackbar控件">Snackbar控件</h2><p>提供一个可供响应的通知提醒</p><pre class=" language-language-java"><code class="language-language-java">Snackbar.make(view,"这是一个Snackbar",Snackbar.LENGTH_SHORT).setAction("点击事件", new View.OnClickListener() {@Overridepublic void onClick(View view) {Toast.makeText(MainActivity.this,"点击事件发生",Toast.LENGTH_SHORT).show();}})    .addCallback(new Snackbar.Callback() {@Overridepublic void onDismissed(Snackbar transientBottomBar, int event) {super.onDismissed(transientBottomBar, event);            Toast.makeText(MainActivity.this,"onDismissed - 消失",Toast.LENGTH_SHORT).show();}        @Override       public void onShown(Snackbar sb) {       super.onShown(sb);       Toast.makeText(MainActivity.this,"onShown - 出现",Toast.LENGTH_SHORT).show();       }}).show();            </code></pre><h2 id="TextInputLayout控件">TextInputLayout控件</h2><p>作为editText的容器，当点击EditText时，hint字符会自动移到EditText的左上角。常用来做登录界面的帐号密码输入。</p><pre class=" language-language-xml"><code class="language-language-xml"><com.google.android.material.textfield.TextInputLayout        android:layout_width="match_parent"android:layout_height="wrap_content"    app:counterEnabled="true"是否开启计数器                                                   >    <EditText    android:layout_width="match_parent"        android:layout_height="wrap_content"        android:hint="密码"        android:drawableStart="@mipmap/ic_launcher"显示一个提示图片              /></com.google.android.material.textfield.TextInputLayout></code></pre><h2 id="Tablayout控件">Tablayout控件</h2><pre class=" language-language-xml"><code class="language-language-xml">    <com.google.android.material.tabs.TabLayout        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:background="@color/colorPrimary"        android:id="@+id/tab_layout">    </com.google.android.material.tabs.TabLayout>        <androidx.viewpager.widget.ViewPager        android:background="#FFF"        android:id="@+id/view_page"        android:layout_width="match_parent"        android:layout_height="match_parent"        app:layout_behavior="@string/appbar_scrolling_view_behavior">    </androidx.viewpager.widget.ViewPager></code></pre><h3 id="常见属性">常见属性</h3><pre><code>app:tabIndicatorColor ：指示线的颜色app:tabIndicatorHeight ：指示线的高度app:tabSelectedTextColor ： tab选中时的字体颜色app:tabMode="scrollable" ： 默认是fixed，固定的；scrollable：可滚动的</code></pre><h2 id="CardView控件">CardView控件</h2><p>实质为带有圆角背景和阴影的FrameLayout</p><h3 id="常见属性-2">常见属性</h3><pre><code>android：cardBackgroundColor ：设置背景android：cardCornerRadius ：设置圆角app：cardElevation ：设置阴影大小app：cardMaxElevation ：设置阴影的最大高度app：contentPadding ：内容距离边界的距离app：contentPaddingXXX ：设置局部的内边距，替换Padding的，在CardView中设置Padding是不起作用的。app：cardUseCompatPadding ：如果您需要将CardView与其他视图对齐，可能在21以下，可以将此标志设置为真，CardView将在21之后的平台上添加相同的填充值。app：cardPreventCornerOverlap ：是否裁剪边界以防止重叠</code></pre><h2 id="DrawerLayout控件">DrawerLayout控件</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Material Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习之实现启动页面</title>
      <link href="/android-splash.html"/>
      <url>/android-splash.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现一个启动页面">实现一个启动页面</h2><p>在res/drawable下，创建一个xml文件，即为启动页面的效果：</p><pre class=" language-language-xml"><code class="language-language-xml"><?xml version="1.0" encoding="utf-8"?><layer-list xmlns:android="http://schemas.android.com/apk/res/android">    <item android:drawable="@color/colorPrimary"/>    <item>        <bitmap            android:gravity="center"            android:src="@mipmap/ic_launcher"/>    </item></layer-list></code></pre><p>这里关于layer-list的使用可以移步：</p><ul><li><a href="https://blog.csdn.net/north1989/article/details/53485729/" target="_blank" rel="noopener"> layer-list的基本使用介绍</a></li></ul><p>例子使用的启动页为两层，第一层为程序的主色调，第二层为程序的图标，并且位于中间位置；</p><h2 id="绑定到活动">绑定到活动</h2><p>在values/style.xml内新建一个主题：</p><pre class=" language-language-xml"><code class="language-language-xml"><resources>    <style name="SplashTheme" parent="Theme.AppCompat.Light.NoActionBar">        <item name="android:windowBackground">@drawable/splash</item>    </style>    <resources></code></pre><p>主题选择继承<code>Theme.AppCompat.Light.NoActionBar</code>，并且指定背景为刚才创建的界面；</p><p>新建一个SplashActivity活动，在AndroidManifest.xml内设置为启动活动，并为其设置上一步的主题：</p><pre class=" language-language-xml"><code class="language-language-xml"><activity android:name=".SplashActivity"            android:theme="@style/SplashTheme">            <intent-filter>                <action android:name="android.intent.action.MAIN" />                <category android:name="android.intent.category.LAUNCHER" />            </intent-filter>        </activity></code></pre><h2 id="正确的打开页面">正确的打开页面</h2><p>编辑SplashActivity代码，设置启动逻辑：</p><pre class=" language-language-java"><code class="language-language-java">Intent intent = new Intent(getApplicationContext(),MainActivity.class);startActivity(intent);finish();</code></pre><p>如果页面跳转过快，可以设置程序休眠：</p><pre class=" language-language-java"><code class="language-language-java">Thread mythread = new Thread(){@Override    public void run() {    try {        sleep(1500);            Intent intent = new Intent(getApplicationContext(),MainActivity.class);            startActivity(intent);            finish();}catch (Exception e) {        e.printStackTrace();        }    }};mythread.start();</code></pre><p>到这里就大功告成了：</p><iframe height="576" width="324" src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Android/splash.gif"></iframe><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter框架学习笔记</title>
      <link href="/flutter.html"/>
      <url>/flutter.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装与配置">安装与配置</h2><ol><li><p>在flutter官网下载其最新可用的安装包，<a href="https://flutter.io/sdk-archive/#windows" target="_blank" rel="noopener">点击跳转</a>；</p></li><li><p>将安装包zip解压到你想安装Flutter SDK的路径；</p></li><li><p>添加环境变量，<strong>重启</strong>；</p><ul><li><p><code>PUB_HOSTED_URL=https://pub.flutter-io.cn</code></p></li><li><p><code>FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</code></p></li><li><p>在<code>Path</code>一栏，新建一个用户变量，填入flutter的路径地址</p><p>如：<em>C:\Users\Mahoo\Lib\<strong>flutter\bin</strong></em></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Flutter/1.png" alt=""></p></li><li><p>打开Android Studio，选择Flie -&gt; Setting -&gt; Plugins，安装<strong>Flutter</strong>和<strong>Dart</strong>，如果插件列表加载失败，可尝试在File-&gt;setting-&gt;Appearance&amp;Behavior-&gt; System Settings-&gt;updates 中<strong>取消勾选 Use secure connection</strong>；</p><p>如果还是无法显示通过下载zip安装包进行安装：</p><ul><li><p>查看Android Studio版本；</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Flutter/2.png" alt=""></p></li><li><p>在<a href="https://plugins.jetbrains.com/plugin/9212-flutter/versions" target="_blank" rel="noopener">jetbrains</a>下载对应版本的插件；</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Flutter/3.png" alt=""></p></li><li><p>在Android Studio内安装即可；</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Flutter/4.png" alt=""></p></li></ul></li><li><p>在控制台（或者PowerShell）输入<code>flutter doctor</code>命令，验证是否已正确配置所有内容：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Flutter/5.png" alt=""></p><p>由于博主使用Android Studio进行开发，所以忽略IntelliJ IDEA的配置；</p></li><li><p>选择Flie -&gt; New -&gt; New Flutter Project，开始你的第一个Flutter Application！</p></li></ol><h2 id="学习基础篇">学习基础篇</h2><h3 id="语言特性">语言特性</h3><ul><li><strong>Dart所有的东西都是对象</strong>， 即使是数字numbers、函数function、null也都是对象，所有的对象都继承自Object类。</li><li><strong>Dart动态类型语言</strong>, 尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在 debug 模式下会类型会是 dynamic(动态的)。</li><li>Dart 在 running 之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度。</li><li>Dart中的类和接口是统一的，类即接口，你可以继承一个类，也可以实现一个类（接口），自然也包含了良好的面向对象和并发编程的支持。</li><li>Dart 提供了顶级函数(如：main())，同时还支持定义属于类或对象的函数（即 <em>静态</em> 和 <em>实例方法</em>）。你还可以在函数中定义函数（<em>嵌套</em> 或 <em>局部函数</em>）。</li><li>Dart 没有 public、private、protected 这些关键字，变量名以"_"开头意味着对它的 lib 是私有的。</li><li><strong>没有初始化的变量都会被赋予默认值 null。</strong></li><li>final的值只能被设定一次。const 是一个编译时的常量，可以通过 const 来创建常量值，var c=const[];，这里 c 还是一个变量，只是被赋值了一个常量值，它还是可以赋其它值。实例变量可以是 final，但不能是  const。</li><li>编程语言并不是孤立存在的，Dart也是这样，他由语言规范、虚拟机、类库和工具等组成：<ul><li>SDK：SDK 包含 Dart VM、dart2js、Pub、库和工具。</li><li>Dartium：内嵌 Dart VM 的 Chromium ，可以在浏览器中直接执行 dart 代码。</li><li>Dart2js：将 Dart 代码编译为 JavaScript 的工具。</li><li>Dart Editor：基于 Eclipse 的全功能 IDE，并包含以上所有工具。支持代码补全、代码导航、快速修正、重构、调试等功能。</li></ul></li><li>Dart 中 <em>表达式</em> 和 <em>语句</em> 是有区别的，表达式有值而语句没有。比如条件表达式<code>expression condition ? expr1 : expr2</code> 中含有值 <code>expr1</code> 或 <code>expr2</code>。与 if-else 分支语句相比，<code>if-else</code> 分支语句则没有值。一个语句通常包含一个或多个表达式，但是一个表达式不能只包含一个语句。</li></ul><h3 id="注释">注释</h3><ul><li><p>单行注释</p><blockquote><p>以<code>//</code>开头，Dart会忽略//与行尾之间的所有内容</p></blockquote><pre class=" language-language-dart"><code class="language-language-dart">//这是一个单行注释</code></pre></li><li><p>多行注释</p><blockquote><p>以<code>/*</code>开头，以<code>*/</code>结尾，介于其中的内容都会被忽略，且可以嵌套注释</p></blockquote><pre class=" language-language-dart"><code class="language-language-dart">/*/*这是一个多行注释*/*/</code></pre></li><li><p>文档注释</p><blockquote><p>文档注释以<code>///</code>或<code>/**</code>开头，并可以通过<code>dartdoc</code>命令导出文档</p></blockquote><pre class=" language-language-dart"><code class="language-language-dart">///这是一个文档注释</code></pre></li></ul><h3 id="关键字">关键字</h3><h4 id="33个保留字">33个保留字</h4><p>不能使用保留字作为标识符</p><table><thead><tr><th style="text-align:center">if</th><th style="text-align:center">superdo</th><th style="text-align:center">switch</th><th style="text-align:center">assert</th></tr></thead><tbody><tr><td style="text-align:center">else</td><td style="text-align:center">in</td><td style="text-align:center">this</td><td style="text-align:center">enum</td></tr><tr><td style="text-align:center">is</td><td style="text-align:center">throw</td><td style="text-align:center">true</td><td style="text-align:center">break</td></tr><tr><td style="text-align:center">new</td><td style="text-align:center">try</td><td style="text-align:center">case</td><td style="text-align:center">extrends</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">typedef</td><td style="text-align:center">catch</td><td style="text-align:center">var</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">false</td><td style="text-align:center">void</td><td style="text-align:center">const</td></tr><tr><td style="text-align:center">final</td><td style="text-align:center">rethrow</td><td style="text-align:center">while</td><td style="text-align:center">continue</td></tr><tr><td style="text-align:center">finally</td><td style="text-align:center">return</td><td style="text-align:center">with</td><td style="text-align:center">for</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h4 id="内置标志符">内置标志符</h4><table><thead><tr><th style="text-align:center">abstract</th><th style="text-align:center">deferred</th><th style="text-align:center">as</th><th style="text-align:center">dynamic</th></tr></thead><tbody><tr><td style="text-align:center">covariant</td><td style="text-align:center">export</td><td style="text-align:center">external</td><td style="text-align:center">factory</td></tr><tr><td style="text-align:center">get</td><td style="text-align:center">implements</td><td style="text-align:center">import</td><td style="text-align:center">library</td></tr><tr><td style="text-align:center">operator</td><td style="text-align:center">part</td><td style="text-align:center">set</td><td style="text-align:center">static</td></tr><tr><td style="text-align:center">typedef</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="常量和变量">常量和变量</h3><h4 id="Final-和-Const">Final 和 Const</h4><p>如果你不想更改一个变量，可以使用关键字 <code>final</code> 或者 <code>const</code> 修饰变量，这两个关键字可以替代 <code>var</code> 关键字或者加在一个具体的类型前。一个 final 变量只可以被赋值一次；一个 const 变量是一个编译时常量（const 变量同时也是 final 的）。<strong>顶层的 final 变量或者类的 final 变量在其第一次使用的时候被初始化</strong>。</p><ul><li>flnal 或者 const 不能和 var 同时使用</li></ul><pre class=" language-language-dart"><code class="language-language-dart">// Members can't be declared to be both 'const' and 'var' const var String Name = 'mahoo';  // Members can't be declared to be both 'final' and 'var' final var String name = 'Mahoo';</code></pre><ul><li><p>变量存储引用</p><pre class=" language-language-dart"><code class="language-language-dart">dynamic name = '张三';</code></pre></li><li><p>如果对象不限于单一类型（没有明确的类型），请使用Object或dynamic关键字</p><pre class=" language-language-dart"><code class="language-language-dart">Object name = '张三';dynamic name = '李四';</code></pre></li></ul><p>使用关键字 <code>const</code> 修饰变量表示该变量为 <strong>编译时常量</strong>。如果使用 const 修饰类中的变量，则必须加上 static 关键字，即 <code>static const</code>（注意：顺序不能颠倒（译者注））。在声明 const 变量时可以直接为其赋值，也可以使用其它的 const 变量为其赋值：</p><pre class=" language-language-dart"><code class="language-language-dart">const bar = 1000000; // 直接赋值const double atm = 1.01325 * bar; // 利用其它 const 变量赋值</code></pre><p><code>const</code> 关键字不仅仅可以用来定义常量，还可以用来创建 <em>常量值</em>，该常量值可以赋予给任何变量。你也可以<strong>将构造函数声明为 const 的，这种类型的构造函数创建的对象是不可改变的</strong>。</p><pre class=" language-language-dart"><code class="language-language-dart">var foo = const [];final bar = const [];const baz = []; // 相当于 const []</code></pre><p>如果使用初始化表达式为常量赋值可以省略掉关键字 <code>const</code>，比如上面的常量 <code>baz</code> 的赋值就省略掉了 <code>const</code>。</p><h3 id="数据类型">数据类型</h3><h4 id="Map集合"><strong>Map集合</strong></h4><p>一般来说，map是将键和值相关联的对象。键和值都可以是任何类型的对象。<br><u>每个键只出现一次，但可以多次使用相同的值</u>。Dart支持map由map文字和map类型提供。</p><ul><li>直接声明</li></ul><p>用{}表示，里面写key和value，每组键值对中间用逗号隔开。</p><pre class=" language-language-dart"><code class="language-language-dart">Map companys = {'Alibaba': '阿里巴巴', 'Tencent': '腾讯', 'baidu': '百度'};</code></pre><ul><li><p>先声明，后赋值</p><pre class=" language-language-dart"><code class="language-language-dart"> Map schoolsMap = new Map(); schoolsMap['first'] = '清华'; schoolsMap['second'] = '北大'; schoolsMap['third'] = '复旦';</code></pre></li><li><p>Map API</p><pre class=" language-language-dart"><code class="language-language-dart">// 指定键值对的参数类型var aMap = new Map<int, String>();// Map的赋值，中括号中是Key，这里可不是数组aMap[1] = '老黄';//Map中的键值对是唯一的//同Set不同，第二次输入的Key如果存在，Value会覆盖之前的数据aMap[1] = 'mahoo';// map里面的value可以相同aMap[2] = 'mahoo';// map里面value可以为空字符串aMap[3] = '';// map里面的value可以为nullaMap[4] = null;print(aMap);// 检索Map是否含有某Keyassert(aMap.containsKey(1));//删除某个键值对aMap.remove(1); </code></pre></li></ul><h4 id="字符串">字符串</h4><ul><li><p>以 <code>${</code><em>表达式</em><code>}</code> 的形式使用表达式，如果表达式是一个标识符，可以省略掉 {}，如果表达式的结果为一个对象，则 Dart 会调用该对象的 <code>toString</code> 方法来获取一个字符串。</p><pre class=" language-language-dart"><code class="language-language-dart">var height = 170.0;print('我的身高是$height'); //我的身高是170.0</code></pre></li></ul><p>可以使用 <code>+</code> 运算符将两个字符串连接为一个，也可以将多个字符串挨着放一起变为一个：</p><pre class=" language-language-dart"><code class="language-language-dart">var s1 = '可以拼接'    '字符串'    "即便它们不在同一行。";assert(s1 == '可以拼接字符串即便它们不在同一行。');var s2 = '使用加号 + 运算符' + '也可以达到相同的效果。';assert(s2 == '使用加号 + 运算符也可以达到相同的效果。');</code></pre><p>可以使用三个单引号或者三个双引号创建多行字符串：</p><pre class=" language-language-dart"><code class="language-language-dart">var s1 = '''你可以像这样创建多行字符串。''';var s2 = """这也是一个多行字符串。""";</code></pre><p>在字符串前加上 <code>r</code> 作为前缀创建 “raw” 字符串（即不会被做任何处理（比如转义）的字符串）：</p><pre class=" language-language-dart"><code class="language-language-dart">var s = r'在 raw 字符串中，转义字符串 \n 会直接输出 “\n” 而不是转义为换行。';</code></pre><h4 id="List数组">List数组</h4><p>在Dart中，数组是List对象，所以称之为List</p><pre class=" language-language-dart"><code class="language-language-dart">List list = [1, 2, 23];print(list);// 输出结果  [1, 2, 23]</code></pre><p>创建一个编译时常量const的 list :</p><pre class=" language-language-dart"><code class="language-language-dart">List constantList = const[10,3,15];print(constantList);// 输出结果  [10, 3, 15]</code></pre><p>可以使用扩展操作符（<code>...</code>）将一个 List 中的所有元素插入到另一个 List 中：</p><pre class=" language-language-dart"><code class="language-language-dart">var list = [1, 2, 3];var list2 = [0, ...list];assert(list2.length == 4);</code></pre><p>如果扩展操作符右边可能为 null ，你可以使用 null-aware 扩展操作符（<code>...?</code>）来避免产生异常：</p><pre class=" language-language-dart"><code class="language-language-dart">var list;var list2 = [0, ...?list];assert(list2.length == 1);</code></pre><p>下面示例是使用 <strong>Collection If</strong> 来创建一个 List 的示例，它可能包含 3 个或 4 个元素：</p><pre class=" language-language-dart"><code class="language-language-dart">var nav = [  'Home',  'Furniture',  'Plants',  if (promoActive) 'Outlet'//条件判断（if）];</code></pre><p>下面示例是使用 <strong>Collection For</strong> 将列表中的元素修改后添加到另一个列表中的示例：</p><pre class=" language-language-dart"><code class="language-language-dart">var listOfInts = [1, 2, 3];var listOfStrings = [  '#0',  for (var i in listOfInts) '#$i'//循环（for）];assert(listOfStrings[1] == '#1');</code></pre><h4 id="Sets">Sets</h4><p>Dart 中使用 Set 来表示无序且元素唯一的集合，Dart 支持 Set 字面量以及 Set 类型两种形式的 Set。</p><pre class=" language-language-dart"><code class="language-language-dart">var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};</code></pre><p>可以使用在 <code>{}</code> 前加上类型参数的方式创建一个空的 Set，或者将 <code>{}</code> 赋值给一个 Set 类型的变量：</p><pre class=" language-language-dart"><code class="language-language-dart">var names = <String>{};// 类型+{}的形式创建Set。// Set<String> names = {}; // 声明类型变量的形式创建 Set。// var names = {}; // 这样的形式将创建一个 Map 而不是 Set。</code></pre><h3 id="运算符">运算符</h3><table><thead><tr><th>描述</th><th>操作符</th></tr></thead><tbody><tr><td>级联</td><td>…</td></tr><tr><td>如果为空</td><td>??</td></tr></tbody></table><h4 id="as、is与is">as、is与is!</h4><p><code>as</code> 判断属于某种类型<br><code>is</code> 如果对象具有指定的类型，则为true<br><code>is!</code> 如果对象具有指定的类型，则为false</p><h4 id="assert">assert</h4><p>如果布尔条件为false，则使用assert语句来中断正常执行。</p><pre class=" language-language-dart"><code class="language-language-dart">assert(number < 100);// 确保这是一个 https 网址assert(urlString.startsWith('https'));// 要将消息附加到断言，请添加一个字符串作为第二个参数。assert(urlString.startsWith('https'),'URL ($urlString) should start with "https".');</code></pre><h4 id="条件表达式">条件表达式</h4><p><code>条件 ? 表达式 1 : 表达式 2</code>：如果条件为 true，执行表达式 1并返回执行结果，否则执行表达式 2 并返回执行结果。</p><p><code>表达式 1 ?? 表达式 2</code>：如果<code>表达式 1 </code>为非 null 则返回其值，否则执行<code>表达式 2 </code>并返回其值。</p><h3 id="函数">函数</h3><p>Dart 是一种真正面向对象的语言，所以即便函数也是对象并且类型为 Function，这意味着函数可以被赋值给变量或者作为其它函数的参数。你也可以像调用函数一样调用 Dart 类的实例。</p><p>下面是定义一个函数的例子：</p><pre class=" language-language-dart"><code class="language-language-dart">bool isNoble(int atomicNumber) {  return _nobleGases[atomicNumber] != null;}</code></pre><p>虽然高效 Dart 指南建议在<a href="http://www.dartdoc.cn/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious" target="_blank" rel="noopener">公开的 API 上定义返回类型</a>，不过即便不定义，该函数也依然有效：</p><pre class=" language-language-dart"><code class="language-language-dart">isNoble(atomicNumber) {  return _nobleGases[atomicNumber] != null;}</code></pre><p>如果函数体内只包含一个表达式，你可以使用简写语法：</p><pre class=" language-language-dart"><code class="language-language-dart">bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;</code></pre><p><strong>语法 <code>=&gt; 表达式</code> 是 <code>{ return 表达式; }</code> 的简写，<code>=&gt;</code> 有时也称之为胖箭头语法。</strong></p><h4 id="匿名函数"><strong>匿名函数</strong></h4><ul><li>下面的示例定义了一个<strong>具有一个未定义类型参数item的匿名函数</strong>，该函数被list中的每个item调用，输出一个字符串，该字符串包含指定索引处的值。</li></ul><pre class=" language-language-dart"><code class="language-language-dart">var list = ['apples', 'bananas', 'oranges']; list.forEach((item) {     print('${list.indexOf(item)}: $item'); });</code></pre><ul><li>如果函数只包含一条语句，可以使用箭头符号=&gt;来缩短它, 比如上面的例子可以简写成：</li></ul><pre class=" language-language-dart"><code class="language-language-dart">list.forEach((item) => print('${list.indexOf(item)}: $item'));</code></pre><h4 id="可选参数"><strong>可选参数</strong></h4><p>可选的位置参数，用[]它们标记为可选的位置参数：</p><pre class=" language-language-dart"><code class="language-language-dart">String say(String from, String msg, [String device]) {    var result = '$from says $msg';    if (device != null) {       result = '$result with $device';    }    return result;}</code></pre><ul><li>下面是一个不带可选参数调用这个函数的例子：</li></ul><pre class=" language-language-dart"><code class="language-language-dart">say('Mahoo', 'Hello'); //结果是： Mahoo says Hello</code></pre><ul><li>下面是用第三个参数调用这个函数的例子：</li></ul><pre class=" language-language-dart"><code class="language-language-dart">say('Mahoo', 'Hello', 'Xiaomi'); //结果是：Mahoo says Hello with Xiaomi</code></pre><h4 id="命名参数">命名参数</h4><p>当你调用函数时，可以使用 <code>参数名: 参数值</code> 的形式来指定命名参数。例如：</p><pre class=" language-language-dart"><code class="language-language-dart">enableFlags(bold: true, hidden: false);</code></pre><p><strong>定义函数时，使用 <code>{param1, param2, …}</code> 来指定命名参数</strong>：</p><pre class=" language-language-dart"><code class="language-language-dart">/// 设置 [bold] 和 [hidden] 标识……void enableFlags({bool bold, bool hidden}) {...}</code></pre><p>虽然命名参数是可选参数的一种类型，但是你仍然可以使用 <a href="https://pub.flutter-io.cn/documentation/meta/latest/meta/required-constant.html" target="_blank" rel="noopener">@required</a> 注解来标识一个命名参数是必须的参数，此时调用者则必须为该参数提供一个值。例如：</p><pre class=" language-language-dart"><code class="language-language-dart">const Scrollbar({Key key, @required Widget child})</code></pre><p>如果调用者想要通过 <code>Scrollbar</code> 的构造函数构造一个 Scrollbar 对象而不提供 <code>child</code> 参数，则会导致编译错误。</p><h4 id="函数作为变量">函数作为变量</h4><pre class=" language-language-dart"><code class="language-language-dart">// 声明变量var say = (str){  print(str);};// 变量赋值say("hi world");</code></pre><h4 id="函数作为参数传递">函数作为参数传递</h4><pre class=" language-language-dart"><code class="language-language-dart">// 这是一个函数，参数是一个函数void execute(var callback) {    callback();}// 执行该函数，传递一个函数execute(() => print("xxx"))</code></pre><h4 id="词法作用域">词法作用域</h4><p>Dart 是词法有作用域语言，变量的作用域在写代码的时候就确定了，大括号内定义的变量只能在大括号内访问，与 Java 类似。</p><h4 id="词法闭包">词法闭包</h4><p><em>闭包</em> 即一个函数对象，即使函数对象的调用在它原始作用域之外，依然能够访问在它词法作用域内的变量。</p><p>函数可以封闭定义到它作用域内的变量。接下来的示例中，函数 <code>makeAdder()</code> 捕获了变量 <code>addBy</code>。无论函数在什么时候返回，它都可以使用捕获的 <code>addBy</code> 变量。</p><pre class=" language-language-dart"><code class="language-language-dart">/// 返回一个将 [addBy] 添加到该函数参数的函数。Function makeAdder(num addBy) {  return (num i) => addBy + i;}void main() {  // 生成加 2 的函数。  var add2 = makeAdder(2);  // 生成加 4 的函数。  var add4 = makeAdder(4);  assert(add2(3) == 5);  assert(add4(3) == 7);}</code></pre><h4 id="返回值">返回值</h4><p>所有的函数都有返回值。没有显示返回语句的函数最后一行默认为执行 <code>return null;</code>。</p><h3 id="类">类</h3><ul><li><p>使用<code>?.</code>来确认前操作数不为空, 常用来替代<code>.</code> , 避免左边操作数为null引发异常。</p><pre class=" language-language-dart"><code class="language-language-dart">var p = new Point(2,2)//If p is non-null,set its y value to 4.p?.y = 4</code></pre></li><li><p>使用runtimeType方法，在运行中获取对象的类型。该方法将返回Type 类型的变量。</p><pre class=" language-language-dart"><code class="language-language-dart"> print('The type of p is ${p.runtimeType}');</code></pre></li></ul><h4 id="Getter-和-Setter">Getter 和 Setter</h4><p>Getter 和 Setter 是一对用来读写对象属性的特殊方法，上面说过实例对象的每一个属性都有一个隐式的 Getter 方法，如果为非 final 属性的话还会有一个 Setter 方法，你可以使用 <code>get</code> 和 <code>set</code> 关键字为额外的属性添加 Getter 和 Setter 方法：</p><pre class=" language-language-dart"><code class="language-language-dart">class Rectangle {  num left, top, width, height;  Rectangle(this.left, this.top, this.width, this.height);  // 定义两个计算产生的属性：right 和 bottom。  num get right => left + width;  set right(num value) => left = value - width;  num get bottom => top + height;  set bottom(num value) => top = value - height;}void main() {  var rect = Rectangle(3, 4, 20, 15);  assert(rect.left == 3);  rect.right = 12;  assert(rect.left == -8);}</code></pre><p>使用 Getter 和 Setter 的好处是，你可以先使用你的实例变量，过一段时间过再将它们包裹成方法且不需要改动任何代码，即先定义后更改且不影响原有逻辑。</p><h4 id="构造函数">构造函数</h4><ul><li>声明一个和类名相同的函数，来作为类的构造函数。</li></ul><pre class=" language-language-dart"><code class="language-language-dart">class Point {   num x;   num y;   Point(num x, num y) {      this.x = x;      this.y = y;   }}</code></pre><ul><li>this关键字指向了当前类的实例, 上面的代码可以简化为：</li></ul><pre class=" language-language-dart"><code class="language-language-dart">class Point {   num x;   num y;      Point(this.x, this.y); }</code></pre><p>Dart 语言中，子类不会继承父类的命名构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p><ul><li><strong>命名的构造函数</strong></li></ul><p>使用命名构造函数从另一类或现有的数据中快速实现构造函数。</p><pre class=" language-language-dart"><code class="language-language-dart">class Point {   num x;   num y;   Point(this.x, this.y);   // 命名构造函数Named constructor   Point.fromJson(Map json) {     x = json['x'];     y = json['y'];   }}</code></pre><h4 id="noSuchMethod">noSuchMethod()</h4><p>要在代码尝试使用不存在的方法或实例变量时检测或做出反应，您可以重写<code>noSuchMethod()</code></p><pre class=" language-language-dart"><code class="language-language-dart">class TestMethod {// 除非你重写noSuchMethod，否则使用不存在的成员会导致NoSuchMethodError  @override  void noSuchMethod(Invocation invocation) {    print('You tried to use a non-existent member: ' +        '${invocation.memberName}');  }dynamic foo();}</code></pre><h4 id="抽象类">抽象类</h4><p>使用abstract修饰符定义抽象类（无法实例化的类）。抽象类对于定义接口非常有用，通常还有一些实现。如果希望抽象类看起来是可实例化的，请定义工厂构造函数。</p><h4 id="静态方法">静态方法</h4><p>静态方法（即类方法）不能被一个类的实例访问，同样地，静态方法内也不可以使用 <code>this</code>：</p><pre class=" language-language-dart"><code class="language-language-dart">import 'dart:math';class Point {  num x, y;  Point(this.x, this.y);  static num distanceBetween(Point a, Point b) {    var dx = a.x - b.x;    var dy = a.y - b.y;    return sqrt(dx * dx + dy * dy);  }}void main() {  var a = Point(2, 2);  var b = Point(4, 4);  var distance = Point.distanceBetween(a, b);  assert(2.8 < distance && distance < 2.9);  print(distance);}</code></pre><h3 id="异常">异常</h3><h4 id="throw">throw</h4><pre class=" language-language-dart"><code class="language-language-dart">throw FormatException('Expected at least 1 section');</code></pre><h4 id="try-catch">try catch</h4><p>可以<code>使用on或catch</code>或<code>两者兼而有之</code>。使用<code>on时需要指定异常类型</code>。使用catch时，你的异常处理程序需要异常对象。</p><pre class=" language-language-dart"><code class="language-language-dart">try {  breedMoreLlamas();} on OutOfLlamasException {  // A specific exception  buyMoreLlamas();} on Exception catch (e) {  // Anything else that is an exception  print('Unknown exception: $e');} catch (e) {  // No specified type, handles all  print('Something really unknown: $e');}</code></pre><p>可以指定一个或两个参数catch()。第一个是抛出的异常，第二个是堆栈跟踪（StackTrace对象）。</p><pre class=" language-language-dart"><code class="language-language-dart">try {  // ···} on Exception catch (e) {  print('Exception details:\n $e');} catch (e, s) {  print('Exception details:\n $e');  print('Stack trace:\n $s');}</code></pre><h2 id="实战开发篇">实战开发篇</h2><h3 id="注意">注意</h3><ul><li>使用了Material 风格的widget 就需要Scaffold作为根布局</li></ul><h3 id="导入包">导入包</h3><pre class=" language-language-dart"><code class="language-language-dart">import 'package:flutter/material.dart';</code></pre><p>导入了Material UI组件库，<a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material</a>是一种标准的移动端和web端的视觉设计语言， Flutter默认提供了一套丰富的Material风格的UI组件。</p><h3 id="应用入口">应用入口</h3><pre class=" language-language-dart"><code class="language-language-dart">void main() => runApp(MyApp());</code></pre><ul><li>与C/C++、Java类似，Flutter 应用中<code>main</code>函数为应用程序的入口。<code>main</code>函数中调用了<code>runApp</code> 方法，它的功能是启动Flutter应用。<code>runApp</code>它接受一个<code>Widget</code>参数，在本示例中它是一个<code>MyApp</code>对象，<code>MyApp()</code>是Flutter应用的根组件。</li><li><code>main</code>函数使用了(<code>=&gt;</code>)符号，这是Dart中单行函数或方法的简写。</li></ul><h3 id="应用结构">应用结构</h3><pre class=" language-language-dart"><code class="language-language-dart">class MyApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return new MaterialApp(      //应用名称        title: 'Flutter Demo',       theme: new ThemeData(        //蓝色主题          primarySwatch: Colors.blue,      ),      //应用首页路由        home: new MyHomePage(title: 'Flutter Demo Home Page'),    );  }}</code></pre><ul><li><code>MyApp</code>类代表Flutter应用，它继承了 <code>StatelessWidget</code>类，这也就意味着应用本身也是一个widget。</li><li>在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。</li><li>Flutter在构建页面时，会调用组件的<code>build</code>方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。</li><li><code>MaterialApp</code> 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。<code>MaterialApp</code>也是一个widget。</li><li><code>Scaffold</code> 是Material库中提供的页面脚手架，它包含导航栏和Body以及<code>FloatingActionButton</code>（如果需要的话）。 本书后面示例中，路由默认都是通过<code>Scaffold</code>创建。</li><li><code>home</code> 为Flutter应用的首页，它也是一个widget。</li></ul><h4 id="首页">首页</h4><pre class=" language-language-dart"><code class="language-language-dart">class MyHomePage extends StatefulWidget {     MyHomePage({Key key, this.title}) : super(key: key);     final String title;     @override     _MyHomePageState createState() => new _MyHomePageState();   }   class _MyHomePageState extends State<MyHomePage> {    ...   }</code></pre><p><code>MyHomePage</code> 是Flutter应用的首页，它继承自<code>StatefulWidget</code>类，表示它是一个有状态的组件（Stateful widget）。其区别为：</p><ol><li><p>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</p></li><li><p>Stateful widget至少由两个类组成：</p><ul><li>一个<code>StatefulWidget</code>类。</li><li>一个 <code>State</code>类； <code>StatefulWidget</code>类本身是不变的，但是<code>State</code>类中持有的状态在widget生命周期中可能会发生变化。</li></ul></li></ol><p><code>_MyHomePageState</code>类是<code>MyHomePage</code>类对应的状态类。看到这里，读者可能已经发现：和<code>MyApp</code> 类不同， <code>MyHomePage</code>类中并没有<code>build</code>方法，取而代之的是，<code>build</code>方法被挪到了<code>_MyHomePageState</code>方法中，至于为什么这么做，先留个疑问，在分析完完整代码后再来解答。</p><h5 id="State类">State类</h5><p>接下来，我们看看<code>_MyHomePageState</code>中都包含哪些东西：</p><ol><li><p>该组件的状态。由于我们只需要维护一个点击次数计数器，所以定义一个<code>_counter</code>状态：</p><pre class=" language-language-dart"><code class="language-language-dart">int _counter = 0; //用于记录按钮点击的总次数</code></pre><p><code>_counter</code> 为保存屏幕右下角带“+”号按钮点击次数的状态。</p></li><li><p>设置状态的自增函数。</p><pre class=" language-language-dart"><code class="language-language-dart">void _incrementCounter() {  setState(() {     _counter++;  });}</code></pre><p>当按钮点击时，会调用此函数，该函数的作用是先自增<code>_counter</code>，然后调用<code>setState</code> 方法。<code>setState</code>方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行<code>build</code>方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。</p></li><li><p>构建UI界面</p><p>构建UI界面的逻辑在<code>build</code>方法中，当<code>MyHomePage</code>第一次创建时，<code>_MyHomePageState</code>类会被创建，当初始化完成后，Flutter框架会调用Widget的<code>build</code>方法来构建widget树，最终将widget树渲染到设备屏幕上。所以，我们看看<code>_MyHomePageState</code>的<code>build</code>方法中都干了什么事：</p><pre class=" language-language-dart"><code class="language-language-dart">  Widget build(BuildContext context) {    return new Scaffold(      appBar: new AppBar(        title: new Text(widget.title),      ),      body: new Center(        child: new Column(          mainAxisAlignment: MainAxisAlignment.center,          children: <Widget>[            new Text(              'You have pushed the button this many times:',            ),            new Text(              '$_counter',              style: Theme.of(context).textTheme.display1,            ),          ],        ),      ),      floatingActionButton: new FloatingActionButton(        onPressed: _incrementCounter,        tooltip: 'Increment',        child: new Icon(Icons.add),      ),    );  }</code></pre><ul><li><code>Scaffold</code> 是 Material组件库中提供的一个组件，它提供了默认的导航栏、标题和包含主屏幕widget树（后同“组件树”或“部件树”）的<code>body</code>属性。组件树可以很复杂。</li><li><code>body</code>的组件树中包含了一个<code>Center</code> 组件，<code>Center</code> 可以将其子组件树对齐到屏幕中心。此例中， <code>Center</code> 子组件是一个<code>Column</code> 组件，<code>Column</code>的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中<code>Column</code>子组件是两个 <code>Text</code>，第一个<code>Text</code> 显示固定文本 “You have pushed the button this many times:”，第二个<code>Text</code> 显示<code>_counter</code>状态的数值。</li><li><code>floatingActionButton</code>是页面右下角的带“+”的悬浮按钮，它的<code>onPressed</code>属性接受一个回调函数，代表它被点击后的处理器，本例中直接将<code>_incrementCounter</code>方法作为其处理函数。</li></ul></li></ol><p>现在，我们将整个计数器执行流程串起来：当右下角的<code>floatingActionButton</code>按钮被点击之后，会调用<code>_incrementCounter</code>方法。在<code>_incrementCounter</code>方法中，首先会自增<code>_counter</code>计数器（状态），然后<code>setState</code>会通知Flutter框架状态发生变化，接着，Flutter框架会调用<code>build</code>方法以新的状态重新构建UI，最终显示在设备屏幕上。</p><h4 id="路由管理">路由管理</h4><p>路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter中的路由管理和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p><h5 id="MaterialPageRoute">MaterialPageRoute</h5><p><code>MaterialPageRoute</code>继承自<code>PageRoute</code>类，<code>PageRoute</code>类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还<strong>定义了路由构建及切换时过渡动画的相关接口及属性</strong>。<code>MaterialPageRoute</code> 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画：</p><ul><li>对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。</li><li>对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。</li></ul><p>下面我们介绍一下<code>MaterialPageRoute</code> 构造函数的各个参数的意义：</p><pre class=" language-language-dart"><code class="language-language-dart">  MaterialPageRoute({    WidgetBuilder builder,    RouteSettings settings,    bool maintainState = true,    bool fullscreenDialog = false,  })</code></pre><ul><li><code>builder</code> 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。</li><li><code>settings</code> 包含路由的配置信息，如路由名称、是否初始路由（首页）。</li><li><code>maintainState</code>：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置<code>maintainState</code>为false。</li><li><code>fullscreenDialog</code>表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果<code>fullscreenDialog</code>为<code>true</code>，新页面将会从屏幕底部滑入（而不是水平方向）。</li></ul><blockquote><p>如果想自定义路由切换动画，可以自己继承PageRoute来实现，我们将在后面介绍动画时，实现一个自定义的路由组件。</p></blockquote><h5 id="Navigator">Navigator</h5><p><code>Navigator</code>是一个路由管理的组件，它提供了打开和退出路由页方法。<code>Navigator</code>通过一个栈来管理活动路由集合。通常<strong>当前屏幕显示的页面就是栈顶的路由</strong>。<code>Navigator</code>提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：</p><ul><li><h3 id="Future-push-BuildContext-context-Route-route">Future push(BuildContext context, Route route)</h3><p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。</p></li><li><h3 id="bool-pop-BuildContext-context-result">bool pop(BuildContext context, [ result ])</h3><p>将栈顶路由出栈，<code>result</code>为页面关闭时返回给上一个页面的数据。</p></li></ul><p><code>Navigator</code> 还有很多其它方法，如<code>Navigator.replace</code>、<code>Navigator.popUntil</code>等，详情请参考API文档或SDK源码注释，在此不再赘述。</p><h5 id="命名路由">命名路由</h5><p>所谓“命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。</p><h6 id="路由表">路由表</h6><p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下：</p><pre class=" language-language-dart"><code class="language-language-dart">Map<String, WidgetBuilder> routes;</code></pre><p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回。</p><h6 id="注册路由表">注册路由表</h6><p>路由表的注册方式很简单，我们回到之前“计数器”的示例，然后在<code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性，代码如下：</p><pre class=" language-language-dart"><code class="language-language-dart">MaterialApp(  title: 'Flutter Demo',  theme: ThemeData(    primarySwatch: Colors.blue,  ),  //注册路由表  routes:{   "new_page":(context)=>NewRoute(),    ... // 省略其它路由注册信息  } ,  home: MyHomePage(title: 'Flutter Demo Home Page'),);</code></pre><p>现在我们就完成了路由表的注册。上面的代码中<code>home</code>路由并没有使用命名路由，如果我们也想将<code>home</code>注册为命名路由应该怎么做呢？其实很简单，直接看代码：</p><pre class=" language-language-dart"><code class="language-language-dart">MaterialApp(  title: 'Flutter Demo',  initialRoute:"/", //名为"/"的路由作为应用的home(首页)  theme: ThemeData(    primarySwatch: Colors.blue,  ),  //注册路由表  routes:{   "new_page":(context)=>NewRoute(),   "/":(context)=> MyHomePage(title: 'Flutter Demo Home Page'), //注册首页路由  } );</code></pre><p>可以看到，我们只需在路由表中注册一下<code>MyHomePage</code>路由，然后将其名字作为<code>MaterialApp</code>的<code>initialRoute</code>属性值即可，该属性决定应用的初始路由页是哪一个命名路由。</p><h6 id="通过路由名打开新路由页">通过路由名打开新路由页</h6><p>要通过路由名称来打开新路由，可以使用<code>Navigator</code> 的<code>pushNamed</code>方法：</p><pre class=" language-language-dart"><code class="language-language-dart">Future pushNamed(BuildContext context, String routeName,{Object arguments})</code></pre><p><code>Navigator</code> 除了<code>pushNamed</code>方法，还有<code>pushReplacementNamed</code>等其他管理命名路由的方法，读者可以自行查看API文档。接下来我们通过路由名来打开新的路由页，修改<code>FlatButton</code>的<code>onPressed</code>回调代码，改为：</p><pre class=" language-language-dart"><code class="language-language-dart">onPressed: () {  Navigator.pushNamed(context, "new_page");  //Navigator.push(context,  //  new MaterialPageRoute(builder: (context) {  //  return new NewRoute();  //}));  },</code></pre><p>热重载应用，再次点击“open new route”按钮，依然可以打开新的路由页。</p><h6 id="命名路由参数传递">命名路由参数传递</h6><p>在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数：</p><p>我们先注册一个路由：</p><pre class=" language-language-dart"><code class="language-language-dart"> routes:{   "new_page":(context)=>EchoRoute(),  } ,</code></pre><p>在路由页通过<code>RouteSetting</code>对象获取路由参数：</p><pre class=" language-language-dart"><code class="language-language-dart">class EchoRoute extends StatelessWidget {  @override  Widget build(BuildContext context) {    //获取路由参数      var args=ModalRoute.of(context).settings.arguments    //...省略无关代码  }}</code></pre><p>在打开路由时传递参数</p><pre class=" language-language-dart"><code class="language-language-dart">Navigator.of(context).pushNamed("new_page", arguments: "hi");</code></pre><h6 id="适配">适配</h6><p>假设我们也想将上面路由传参示例中的<code>TipRoute</code>路由页注册到路由表中，以便也可以通过路由名来打开它。但是，由于<code>TipRoute</code>接受一个<code>text</code> 参数，我们如何在不改变<code>TipRoute</code>源码的前提下适配这种情况？其实很简单：</p><pre class=" language-language-dart"><code class="language-language-dart">MaterialApp(  ... //省略无关代码  routes: {   "tip2": (context){     return TipRoute(text: ModalRoute.of(context).settings.arguments);   }, }, );</code></pre><h4 id="更新启动页">更新启动页</h4><p>在Flutter框架加载时，Flutter会使用本地平台机制绘制启动页。此启动页将持续到Flutter渲染应用程序的第一帧时。</p><blockquote><p><strong>注意:</strong> 这意味着如果您不在应用程序的<code>main()</code>方法中调用<a href="https://docs.flutter.io/flutter/widgets/runApp.html" target="_blank" rel="noopener">runApp</a> 函数 （或者更具体地说，如果您不调用<a href="https://docs.flutter.io/flutter/dart-ui/Window/render.html" target="_blank" rel="noopener"><code>window.render</code></a>去响应<a href="https://docs.flutter.io/flutter/dart-ui/Window/onDrawFrame.html" target="_blank" rel="noopener"><code>window.onDrawFrame</code></a>）的话， 启动屏幕将永远持续显示。</p></blockquote><h5 id="Android">Android</h5><p>要将启动屏幕（splash screen）添加到您的Flutter应用程序， 请导航至<code>.../android/app/src/main</code>。在<code>res/drawable/launch_background.xml</code>，通过自定义drawable来实现自定义启动界面（你也可以直接换一张图片）。</p><h5 id="iOS">iOS</h5><p>要将图片添加到启动屏幕（splash screen）的中心，请导航至<code>.../ios/Runner</code>。在<code>Assets.xcassets/LaunchImage.imageset</code>， 拖入图片，并命名为<code>LaunchImage.png</code>、<code>LaunchImage@2x.png</code>、<code>LaunchImage@3x.png</code>。 如果你使用不同的文件名，那您还必须更新同一目录中的<code>Contents.json</code>文件，图片的具体尺寸可以查看苹果官方的标准。</p><h3 id="基础组件">基础组件</h3><h4 id="Widget和Element">Widget和Element</h4><p><strong>Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个Element</strong>。这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个<code>Element</code>节点都会对应一个Widget对象：</p><ul><li>Widget实际上就是<code>Element</code>的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由<code>Element</code>构成；不过，由于<code>Element</code>是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li><li>一个Widget对象可以对应多个<code>Element</code>对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</li></ul><h4 id="mainAxisAlignment">mainAxisAlignment</h4><p>MainAxisAlignment（主轴）和CrossAxisAlignment（交叉轴）常用于 Row 和 Column 控件中，主要是用来控制子控件排列的位置，并可以配合 textDirection 和 verticalDirection 属性来控制子控件排列的方向及改变 MainAxisAlignment 和CrossAxisAlignment的起始位置。</p><p>在水平方向控件中，例如Row：<br>MainAxisAlignment是水平的，默认起始位置在左边，排列方向为从左至右，此时可以通过textDirection来改变MainAxisAlignment的起始位置和排列方向；<br>CrossAxisAlignment是垂直的，默认起始位置在中间，排列方向为从上至下，此时可以通过verticalDirection来改变CrossAxisAlignment的起始位置及排列方向；</p><p>在垂直方向的控件中，例如Column：<br>MainAxisAlignment是垂直的，默认起始位置在上边，排列方向为从上至下，此时可以通过verticalDirection来改变MainAxisAlignment的起始位置及排列方向；<br>CrossAxisAlignment是水平的，默认起始位置在中间，此时可以通过textDirection来改变CrossAxisAlignment的起始位置；</p><ul><li>MainAxisAlignment.spaceBetween：使中间的各个子控件间距相等</li><li>MainAxisAlignment.spaceAround：将主轴空白区域均分，使中间各个子控件间距相等，首尾子控件间距为中间子控件间距的一半</li><li>MainAxisAlignment.start：子控件放在主轴开始位置（类似于android默认Linerlayout排列规则）</li><li>MainAxisAlignment.end：将子控件放在主轴的结束位置</li><li>MainAxisAlignment.center：将子控件放在主轴的中间位置</li><li>MainAxisAlignment.spaceEvenly：将主轴空白区域均分，使各个子控件间距相等</li></ul><p>我们更改一下 <strong>textDirection</strong> 的值设置为文字方向从右至左：</p><pre class=" language-language-dart"><code class="language-language-dart">textDirection: TextDirection.rtl,</code></pre><p>当然，<strong>verticalDirection</strong> 就是用来控制垂直方向的起始位置和排列方向。</p><h4 id="抽屉菜单Drawer">抽屉菜单Drawer</h4><p><code>Scaffold</code>的<code>drawer</code>和<code>endDrawer</code>属性可以分别接受一个Widget来作为页面的左、右抽屉菜单。如果开发者提供了抽屉菜单，那么当用户手指从屏幕左（或右）侧向里滑动时便可打开抽屉菜单。本节开始部分的示例中实现了一个左抽屉菜单<code>MyDrawer</code>，它的源码如下：</p><pre class=" language-language-dart"><code class="language-language-dart">class MyDrawer extends StatelessWidget {  const MyDrawer({    Key key,  }) : super(key: key);  @override  Widget build(BuildContext context) {    return Drawer(      child: MediaQuery.removePadding(        context: context,        //移除抽屉菜单顶部默认留白        removeTop: true,        child: Column(          crossAxisAlignment: CrossAxisAlignment.start,          children: <Widget>[            Padding(              padding: const EdgeInsets.only(top: 38.0),              child: Row(                children: <Widget>[                  Padding(                    padding: const EdgeInsets.symmetric(horizontal: 16.0),                    child: ClipOval(                      child: Image.asset(                        "imgs/avatar.png",                        width: 80,                      ),                    ),                  ),                  Text(                    "Wendux",                    style: TextStyle(fontWeight: FontWeight.bold),                  )                ],              ),            ),            Expanded(              child: ListView(                children: <Widget>[                  ListTile(                    leading: const Icon(Icons.add),                    title: const Text('Add account'),                  ),                  ListTile(                    leading: const Icon(Icons.settings),                    title: const Text('Manage accounts'),                  ),                ],              ),            ),          ],        ),      ),    );  }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android学习之掉坑记录</title>
      <link href="/android.html"/>
      <url>/android.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android8-0及以上版本自定义广播无法接收问题">Android8.0及以上版本自定义广播无法接收问题</h2><p>今天在学习广播过程中发现，自定义广播无效，由于使用的学习参考书是基于Android7.0的，所以，很自然的想到了可能由于版本问题，网上一查，果然。</p><p><strong>原因</strong>：Android8在静态广播的使用上做了一些限制</p><blockquote><p><a href="https://developer.android.google.cn/about/versions/oreo/background#broadcasts" target="_blank" rel="noopener">广播限制</a>：除了有限的例外情况，应用程序无法使用其清单注册隐式广播。他们仍然可以在运行时注册这些广播，并且他们可以使用清单注册专门针对其应用的显式广播。</p></blockquote><p><a href="https://developer.android.google.cn/about/versions/oreo/background" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/oreo/background</a></p><p><strong>解决方法：</strong></p><ul><li><p>保留原来的静态广播，但是加入Component参数</p><pre class=" language-language-java"><code class="language-language-java">Intent intent = new Intent("com.mahoo.broadcast.MY_BROADCAST #自定义广播");intent.setComponent(new ComponentName("com.mahoo.broadcasttest #包名","com.mahoo.broadcasttest.MyBroadcastReceiver #广播接收器地址"));sendBroadcast(intent,null);</code></pre></li><li><p>使用动态注册广播接收器代替静态注册广播接收器</p><pre class=" language-language-java"><code class="language-language-java"># 暂时不会</code></pre></li></ul><h2 id="Android8-0及以上系统通知栏的适配">Android8.0及以上系统通知栏的适配</h2><p>还是一样原因由于参考书较老旧，出现通知栏适配无效的问题，详细地说是方法已被弃用：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/Study/Android/notification.png" alt=""></p><p>从Android 8.0系统开始，Google引入了<strong>通知渠道</strong>这个概念。</p><blockquote><p>通知渠道，顾名思义，就是每条通知都要属于一个对应的渠道。每个App都可以自由地创建当前App拥有哪些通知渠道，但是这些通知渠道的控制权都是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动、或者是否要关闭这个渠道的通知。</p></blockquote><p><strong>解决方法：</strong></p><p>创建通知渠道，在构建通知对象的时候，多传入一个通知渠道ID</p><pre class=" language-language-java"><code class="language-language-java">NotificationCompat.Builder(Context context, String channelId)</code></pre><p>例如：</p><pre class=" language-language-java"><code class="language-language-java">String channelId = "chat";String channelName = "聊天消息";int importance = NotificationManager.IMPORTANCE_HIGH;NotificationChannel channel = new NotificationChannel(channelId, channelName,importance);//向系统注册通知渠道，注册后不能改变重要性以及其他通知行为NotificationManager notificationmanager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);//构建通知渠道notificationManager.createNotificationChannel(channel);Notification notification = new NotificationCompat.Builder(this, "chat")                .setContentTitle("收到一条聊天消息")                .setContentText("通知栏适配成功了")                .setWhen(System.currentTimeMillis())                .setSmallIcon(R.drawable.icon)    .setLargeIcon(BitmapFactory.decodeResource(getResources(),                R.drawable.icon))                .setAutoCancel(true)//设置点击取消通知                .build();manager.notify(1, notification);</code></pre><p>**注：**例子参考于<a href="https://blog.csdn.net/guolin_blog/article/details/79854070" target="_blank" rel="noopener">Android通知栏微技巧，8.0系统中通知栏的适配</a></p><h2 id="Android9-0无法加载http的url">Android9.0无法加载http的url</h2><p>因为从Android 9.0（API级别28）开始，默认情况下限制了明文流量的网络请求，对未加密流量不再信任，直接放弃请求。即http的url均无法在webview中加载，且报错为<code>net::ERR_CLEARTEXT_NOT_PERMITTED</code>。</p><p><strong>解决方法：</strong></p><ul><li><p><sub></sub>在<code>AndroidManifest.xml</code>中打开开关<sub></sub></p><pre class=" language-language-xml"><code class="language-language-xml"><manifest ...>    <application        ...        android:usesCleartextTraffic="true"        ...>        ...    </application></manifest></code></pre></li><li><p>res 下新建 xml 目录，创建文件：<code>network_security_config.xml</code> ，内容如下：</p><pre class=" language-language-xml"><code class="language-language-xml"><?xml version="1.0" encoding="utf-8"?><network-security-config>    <base-config cleartextTrafficPermitted="true" /></network-security-config></code></pre><p>在 AndroidManifest.xml 的 <code>application</code> 标签添加配置：</p><pre class=" language-language-xml"><code class="language-language-xml"><manifest ...>    <application        ...        android:networkSecurityConfig="@xml/network_security_config"        ...>        ...    </application></manifest></code></pre></li></ul><h2 id="安卓8-0以上前台服务通知栏常驻">安卓8.0以上前台服务通知栏常驻</h2><p>这里有个小坑，在9.0中前台服务必须授予FOREGROUND_SERVICE权限：</p><pre class=" language-language-xml"><code class="language-language-xml"><uses-permission android:name="android.permission.FOREGROUND_SERVICE"/></code></pre><p>具体直接查看代码：<a href="https://github.com/Mahoo12138/android_learn_demo/tree/master/ServiceTest" target="_blank" rel="noopener">Android_Service_Demo</a></p><h2 id="在webview中唤醒QQ实现程序的反馈">在webview中唤醒QQ实现程序的反馈</h2><p>重载<code>shouldOverrideUrlLoading</code>方法，因为网页一般调用QQ使用<em><a href="http://wpa.qq.com/msgrd?v=3&amp;uin=QQ%E5%8F%B7&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener">http://wpa.qq.com/msgrd?v=3&amp;uin=QQ号&amp;site=qq&amp;menu=yes</a></em>，通过抓包发现，实际还发送了一个这样的请求<em>mqqwpa://im/chat</em>，此时用一个intent调用QQ即可。</p><pre class=" language-language-java"><code class="language-language-java">webView.setWebViewClient(new WebViewClient() {@Override    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {    if (request.getUrl().toString().startsWith("http") ||request.getUrl().toString().startsWith("https")) {                    return super.shouldOverrideUrlLoading(view, request);                }                else {                    Intent intent = new Intent(Intent.ACTION_VIEW,Uri.parse(request.getUrl().toString())));                    startActivity(intent);                    return true;                }            }        });        webView.loadUrl(url);        finish();}}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用笔记</title>
      <link href="/linux-1.html"/>
      <url>/linux-1.html</url>
      
        <content type="html"><![CDATA[<h1>基本操作</h1><h2 id="基础命令">基础命令</h2><ul><li><code>ls</code>：列举当前目录<ul><li>-a ：显示所有的文件，包括隐藏文件</li><li>-b ：把文件名中不可输出的字符用反斜杠加字符编号形式输出</li><li>-l ：显示文件详细信息（命令<code>ll</code>相当于<code>ls -l</code>）</li></ul></li><li><code>cd</code>：回到当前用户工作目录<ul><li><strong>.</strong>：当前目录</li><li>**… **：父目录</li><li><strong>/</strong>：根目录</li></ul></li><li><code>pwd</code>：查看当前目录</li><li><code>clear</code>：清屏</li></ul><h1>更换软件源</h1><ul><li><p><strong>step 1：<em><em>编辑</em>/etc/apt/sources.list</em>，将默认的</strong><a href="http://archive.ubuntu.com/ubuntu/**%EF%BC%8C%E4%BF%AE%E6%94%B9%E4%B8%BA%EF%BC%9A" target="_blank" rel="noopener">http://archive.ubuntu.com/ubuntu/**，修改为：</a></p><ul><li>阿里云源: <a href="http://mirrors.aliyun.com/ubuntu/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu/</a></li><li>清华源: <a href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu/" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/ubuntu/</a></li></ul></li><li><p>**step 2：**更新源</p><pre class=" language-language-shell"><code class="language-language-shell">sudo apt-get update</code></pre></li><li><p>**step 3：**更新软件</p><pre class=" language-language-shell"><code class="language-language-shell">sudo apt-get dist-upgradesudo apt-get upgrade</code></pre></li></ul><h1>安装和使用Screen</h1><ul><li><p>安装Screen</p><pre class=" language-language-shell"><code class="language-language-shell">apt-get install screen</code></pre></li><li><p>创建一个名为<code>Test</code>的会话：</p><pre class=" language-language-shell"><code class="language-language-shell">screen -S Test</code></pre></li><li><p>使用<code>Ctrl + A + D</code>退出回话</p></li><li><p>查看所有会话：</p><pre class=" language-language-shell"><code class="language-language-shell">screen -ls</code></pre></li><li><p>重新连接会话：</p><pre class=" language-language-shell"><code class="language-language-shell">screen -r Test</code></pre></li></ul><h1>配置Python3环境</h1><ul><li><p>安装<code>python3</code></p><pre class=" language-language-shell"><code class="language-language-shell">apt-get install python3</code></pre></li><li><p>安装<code>pip</code></p><pre class=" language-language-shell"><code class="language-language-shell">apt-get install python3-pip</code></pre><ul><li><p>升级<code>pip</code></p><pre class=" language-language-shell"><code class="language-language-shell">pip3 install --upgrade pip</code></pre></li></ul></li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin语言基础学习</title>
      <link href="/kotlin.html"/>
      <url>/kotlin.html</url>
      
        <content type="html"><![CDATA[<h1>简单介绍</h1><h2 id="定义包">定义包</h2><p>包的声明应处于源文件顶部：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">package my.demoimport java.util.*//...</code></pre><p>目录与包的结构无需匹配：源代码可以放在文件系统的任意位置。</p><h2 id="定义函数">定义函数</h2><p>带有两个<code>Int</code>参数，返回<code>Int</code>函数：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">fun sum (a:Int,b:Int):Int{    return a+b}</code></pre><a id="more"></a><p>将表达式作为函数体，返回值类型自动推送的函数：</p><pre class=" language-language-Kotlin"><code class="language-language-Kotlin">fun sum (a:Int,b:Int) = a + b</code></pre><p>函数返回无意义的值：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">fun printSum(a:Int,b:Int){println("sum $a and $b is ${a+b}")}</code></pre><p><code>Unit</code>返回类型可以省略：</p><pre class=" language-language-Kotlin"><code class="language-language-Kotlin">fun printSum(a:Int,b:Int){    println("sum of $a and $b is ${a+b}")}</code></pre><h2 id="定义变量">定义变量</h2><p>定义<strong>只读局部变量</strong>使用关键字<code>val</code>定义。只能为其赋值一次。</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val a:Int = 1//立即赋值val b = 2//自动推出‘Int’类型val c:Int//如果没有赋初值，则不能省略c = 2//明确赋值</code></pre><p>可重新赋值的变量使用<code>var</code>关键字：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var x = 5x += 1</code></pre><p>顶层变量：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val PI = 3.14var x = 0</code></pre><h2 id="注释">注释</h2><p>正如Java，Kotlin支持行注释及块注释。</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">// 这是一个行注释/* 这是一个多行的   块注释。*/</code></pre><p>与Java不同的是，Kotlin的块注释可以嵌套。</p><h2 id="使用字符串模板">使用字符串模板</h2><p>使用字符串模板的符号为（<code>$</code>）。在<code>$</code>符号后面加上变量名或大括号中的表达式</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var a = 1val s1 = "a is $a"// 模板中的简单名称a = 2val s2 = "${s1.replace("is","was")},but now is $a"//模板中的任意表达式println(s2)</code></pre><p>执行结果：</p><pre><code>a was 1, but now is 2</code></pre><h2 id="声明可空变量">声明可空变量</h2><p>在Kotlin中当我们不确定某个属性或变量一定不为空时，我们就把它声明为<strong>可空变量</strong>.</p><p>可空变量的特点：</p><ul><li>在声明的时候一定要用标准的声明格式定义。不能用可推断类型的简写；</li><li>变量类型后面的<code>?</code>符号不能省略。不然就和普通的变量没区别了；</li><li>其初始化的值可以为<code>null</code>或确定的变量值。</li></ul><pre class=" language-language-kotlin"><code class="language-language-kotlin">class Test{    //声明可空变量    var a:Int? = 0;    val b:Int? = null;}</code></pre><h2 id="常量的用法">常量的用法</h2><p>在Kotlin中<code>val</code>修饰的还不是常量，他只是个不能修改的变量。常量的定义还需要再<code>val</code>关键字前加上<code>const</code>关键字。即：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">const val NUM_A = 6</code></pre><p>其特点：<strong><code>const</code>只能修饰<code>val</code>，不能修饰<code>var</code></strong>。</p><p>声明常量的三种方式：</p><ol><li>在顶层声明；</li><li>在<code>object</code>修饰的类中声明，在<code>kotlin</code>中称为<strong>对象声明</strong>；</li><li>在伴生对象中声明。</li></ol><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">// 1.顶层声明const val Str_A :String = "顶层声明"// 2.在object修饰的类中object TestConst{    const val Str_B = "object修饰的类中"}// 3.在伴生对象中class TestClass{    companion object{        const val Str_C = "在伴生对象中"    }}</code></pre><h1>数据类型</h1><h2 id="数值类型">数值类型</h2><h3 id="1-数字的内置类型">1. 数字的内置类型</h3><ul><li><code>Byte </code> =&gt; 字节 =&gt; 8位</li><li><code>Short</code> =&gt; 短整型 =&gt; 16位</li><li><code>Int</code> =&gt; 整型 =&gt; 32位</li><li><code>Long</code> =&gt; 长整型 =&gt; 64位</li><li><code>Float</code> =&gt; 浮点型 =&gt; 32位</li><li><code>Double</code> =&gt; 双精度浮点型 =&gt; 64位</li></ul><p>注意：</p><ul><li>长整型在数值末用大写字母L标记</li><li>单精度浮点型由字母F（大写小写无妨）标记</li></ul><h3 id="2-进制数">2. 进制数</h3><p>Kotlin不支持八进制数</p><h3 id="3-数字类型字面常量的下划线">3. 数字类型字面常量的下划线</h3><p>作用：<strong>分割数字进行分组，使数字常量更易读</strong></p><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val oneMillion = 1_000_000val phoneNum = 155_0746_2014</code></pre><h3 id="4-装箱与拆箱">4. 装箱与拆箱</h3><p>装箱就是值类型转换为object类型，拆箱相反：object转化为值类型。在<code>kotlin</code>中，存在数字的装箱，但是没有拆箱。因为<code>kotlin</code>是没有基本数据类型的，<code>Kotlin</code>是万物皆对象的原则。</p><p>在<code>kotlin</code>中要实现装箱操作，首先要了解可空引用。即类似<code>Int?</code>(只限数值类型)此类的：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val numValue:Int = 1// 装箱的过程，装箱后其值是没有变化的val numValueBox:Int = numValue</code></pre><h4 id="两个数值的比较">两个数值的比较</h4><ul><li>判断两个数值是否相等<code>==</code></li><li>判断两个数值在内存中的地址是否相等<code>===</code></li></ul><h3 id="5-转换">5. 转换</h3><ul><li><p>显式转换</p><p>较小的类型不会被隐式转换位更大的类型，故而系统提供了显式转换：</p><ul><li><code>toByte()</code> =&gt; 转换为字节型</li><li><code>toShort()</code> =&gt; 转换为短整型</li><li><code>toInt()</code> =&gt; 转换为整型</li><li><code>toLong()</code> =&gt; 转换为长整型</li><li><code>toFloat()</code> =&gt; 转换为浮点型</li><li><code>toDouble()</code> =&gt; 转换为双精度浮点型</li><li><code>toChar()</code> =&gt; 转换为字符型</li><li><code>toString()</code> =&gt; 转换为字符串型</li></ul></li><li><p>隐式转换</p><p>类型是从上下文推断出来的，即算术运算则被重载为适当的转换：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val num = 30L + 12println(num)// 30L + 12 -> Long + Int => Long</code></pre></li></ul><h3 id="6-位运算符">6. 位运算符</h3><p>// 。。。。。</p><h2 id="布尔类型">布尔类型</h2><h3 id="1-关键字">1. 关键字</h3><p><code>Boolean</code>关键字表示布尔类型，并且其值有<code>ture</code>和<code>false</code></p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var isNum:BooleanisNum = false</code></pre><h3 id="2-逻辑操作符">2. 逻辑操作符</h3><ul><li>‘||’ =&gt; 逻辑或</li><li>‘&amp;&amp;’ =&gt; 逻辑与</li><li>‘ ! ’ =&gt; 逻辑非</li></ul><h2 id="字符型">字符型</h2><h3 id="1-关键字-2">1. 关键字</h3><p><code>Char</code>表示字符型，字符变量用单引号(’’)表示。并且不能直接视为数字，不过可以通过显式转换为数字：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var char_1:Charchar = 'a'char = 1//报错</code></pre><h3 id="2-显示转换为其他类型">2. 显示转换为其他类型</h3><p>字符型的变量不仅会可以转换为数字，同时也可转换为其他类型：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var var1 = char_1.toByte()var var2 = char_1.toInt()//...</code></pre><p>除了类型转换，当变量为英文字母时还支持大小写转换：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var charA:Char = 'a'var charB:Char = 'B'var result:Charresult = charA.toUpperCase()//转换为大写result = charB.toLowerCase()//转换为小写</code></pre><h3 id="3-字符转义">3. 字符转义</h3><ul><li><code>\t</code> =&gt; 制表符</li><li><code>\n</code> =&gt; 换行符</li><li><code>\b</code>=&gt; 退格键</li><li><code>\r</code>=&gt; 回车键</li><li><code>\\</code>=&gt; 反斜杠</li><li><code>\'</code>=&gt; 单引号</li><li><code>\$</code> =&gt; 美元符号</li><li>**其他的任何字符请使用Unicode转义序列语法，例如：’\uFF00’</li></ul><h2 id="字符串类型">字符串类型</h2><h3 id="1-关键字-3">1. 关键字</h3><p><code>String</code>表示字符串类型。其实不可变的。所以字符串的元素可以通过索引操作的字符：<code>str[index]</code>来访问。可以使用<code>for</code>循环迭代字符串：其中<code>str[index]</code>中的<code>str</code>要为目标字符串，<code>index</code>才能为索引：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val str:Sting = "kotlin"//迭代for (s in str){    print(s)    print("\t")}</code></pre><h3 id="2-字符串字面量">2. 字符串字面量</h3><p>在<code>Kotlin</code>中，字符串字面量有两种类型：</p><ul><li>包含转义字符的字符串，转义包括（\t, \n等），不包括转义字符串的也同属此类型</li><li>包含任意字符的字符串，有三重引号（<code>"""..."""</code>）表示</li></ul><h2 id="数组型">数组型</h2><ul><li><code>Kotlin中</code>数组由<code>Array&lt;T&gt;表示</code></li><li>创建数组的三个函数：<ul><li><code>arrayOf()</code></li><li><code>arrayOfNulls()</code></li><li>工厂函数（<code>Array()</code>）</li></ul></li></ul><h3 id="1-arrayOf">1. arrayOf()</h3><p>创建一个数组，参数是一个可变参数的泛型对象：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">val arr1 = arrayOf(1,2,3,4,5)for (v in arr1){    print(v)    print("\t")}</code></pre><h3 id="2-arrayOfNulls">2. arrayOfNulls()</h3><p>用于创建一个指定数据类型且可以为空元素的，给定元素个数的数组：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arr2 = arrayOfNulls<Int>(3)// 若不予数组赋值则arr3内元素皆为null</code></pre><h3 id="3-工厂函数">3. 工厂函数</h3><ul><li>使用工厂函数<code>Array()</code>，它使用数组大小和返回给定其索引的每个数组元素的初始值的函数。</li><li><code>Array()</code>=&gt; 第一个参数表示的个数，第二个参数则为使用其下标组成的表达式</li></ul><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arr3 = Array(5,{index -> (index*2).toString()})for (v in arr4){    print(v)    print("\t")}</code></pre><p>执行结果：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">02468</code></pre><h3 id="4-原始类型数组">4. 原始类型数组</h3><p><code>kotlin</code>还有专门的类来表示原始类型的数组，没有装箱开销，它们分别是：</p><ul><li><code>ByteArray</code> =&gt; 表示字节型数组</li><li><code>ShortArray</code> =&gt; 表示短整型数组</li><li><code>IntArray</code> =&gt; 表示整型数组</li><li><code>LongArray</code> =&gt; 表示长整型数组</li><li><code>BooleanArray</code> =&gt; 表示布尔型数组</li><li><code>CharArray</code> =&gt; 表示字符型数组</li><li><code>FloatArray</code> =&gt; 表示浮点型数组</li><li><code>DoubleArray</code> =&gt; 表示双精度浮点型数组</li></ul><p><strong><code>Kotlin</code>不支持字符串类型这种原始类型的数组</strong></p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var intArr:IntArray = intArrayOf(1,2,3,4,5)var charArr:CharArray = charArrayOf('a','b','c','1','2')</code></pre><h1>控制语句</h1><h2 id="if语句">if语句</h2><p><code>kotlin</code>中的<code>if</code>语句很灵活，除了普通的判断，还可以实现表达式（实现三元运算符），及作为一个块的作用</p><h3 id="1-传统写法">1. 传统写法</h3><pre class=" language-language-kotlin"><code class="language-language-kotlin">var numA = 2if (numA == 2){    println($numA)}else{    println($numA-1)}</code></pre><h3 id="2-Kotlin中的三元运算符">2. <code>Kotlin</code>中的三元运算符</h3><p>在<code>Kotlin</code>中其实不存在三元运算符（<em>condition ？ then ： else</em>）这种运算，那是因为if语句的特性：<code>if</code>表达式会返回一个值，所以不需要三元运算符。</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var numB:Int = if (numA > 2) 3 else 5println(numB)</code></pre><h3 id="3-作为一个块结构，并且最后一句表达式为块的值">3. 作为一个块结构，并且最后一句表达式为块的值</h3><pre class=" language-language-kotlin"><code class="language-language-kotlin">var numA:Int = 2var numC:Int = if(numA > 2){    numA = 10numA}else if (numA == 2){    numA = 20    numA}else{    numA = 30    numA}</code></pre><h2 id="for语句">for语句</h2><ul><li><code>for</code>循环提供迭代器用来遍历任何东西</li><li><code>for</code>循环数组被编译为一个基于索引的循环，它不会创建一个迭代器对象</li></ul><h3 id="规则">规则</h3><ul><li><p>递增</p><ul><li><p>关键字：<code>until</code></p></li><li><p>范围：<code>until[n,m]</code> =&gt; 大于等于n，小于m</p></li><li><p>例如：</p></li></ul><pre class=" language-language-kotlin"><code class="language-language-kotlin">// 循环5次，且步长为1的递增for (i in 0 until 5){    print(i)}</code></pre></li><li><p>递减</p><ul><li>关键字：<code>downTo</code></li></ul><ul><li><p>范围：<code>downTo[n,m]</code> =&gt; 大于等于n，小于等于m，n &gt; m</p></li><li><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">// 循环5次，且步长为1的递减for(i in 15 downTo 11){    print(i)}</code></pre></li></ul></li><li><p>符号(<code>..</code>)</p><p>表示递增循环的另外一种操作</p><ul><li><p>使用符号<code>..</code></p></li><li><p>范围：<code>..[n,m]</code> =&gt; 即<code>大于等于n,小于等于m</code></p></li><li><p>和<code>until</code>有区别，但更为简便，且范围不同</p></li><li><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">for (i in 20..25){    print(i)}</code></pre></li></ul></li><li><p>设置步长</p><ul><li><p>关键字：<code>step</code></p></li><li><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">for (i in 10 until 16 step 2){    print(i)}</code></pre></li></ul></li></ul><h3 id="遍历字符串">遍历字符串</h3><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">for (i in "asdfghjk"){    print(i)}</code></pre><h3 id="遍历数组">遍历数组</h3><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arrayList = arrayOf(1,3,5,7,9)for (i in arrayList){    print(i)}</code></pre><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arrayList = arrayOf(1,3,5,7,9)for (i in arrayListTwo.indices){    println("arrayList[$i] => " + arrayList[i])}</code></pre><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arrayList = arrayOf(1,3,5,7,9)for ((index,value) in arrayList.withIndex()){    println("index => $index \t value => $value")}</code></pre><h4 id="使用列表或数组的扩展函数遍历">使用列表或数组的扩展函数遍历</h4><ul><li>数组或列表有一个成员或扩展函数<code>iterator()</code>实现了<code>Iterator&lt;T&gt;</code>接口，且该接口提供了<code>next()</code>与<code>hasNext()</code>两个成员或扩展函数</li><li>其一般和<code>while</code>循环一起使用</li></ul><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arrayList = arrayOf(2,'a',3,false,9)var iterator: Iterator<Any> = arrayList.iterator()while (iterator.hasNext()){    println(iterator.next())}</code></pre><h2 id="when语句">when语句</h2><p><code>when</code>语句类似于C类语言中的<code>switch</code>语句，不过比它更强大。</p><h3 id="实现switch语句功能">实现switch语句功能</h3><pre class=" language-language-kotlin"><code class="language-language-kotlin">when(5){    1 -> {        print("1")    }    2 -> {        print("2")    }    esle -> {        print("5")    }}</code></pre><h3 id="与逗号结合">与逗号结合</h3><pre class=" language-language-kotlin"><code class="language-language-kotlin">when(1){    // 即值为1，2，3时都输出1    1,2,3 -> {        print("1")    }    else -> {        print("0")    }}</code></pre><h3 id="条件可以使用任意表达式">条件可以使用任意表达式</h3><pre class=" language-language-kotlin"><code class="language-language-kotlin">var num:Int = 5when (num > 5){    true -> {        print("num > 5")    }    false -> {        print("num < 5")    }    else -> {        print("num = 5")    }}</code></pre><h3 id="检查值是否存在于集合或数组中">检查值是否存在于集合或数组中</h3><ol><li><p>操作符</p><ul><li><code>in</code>在</li><li><code>!in</code>不在</li></ul></li><li><p>限定：只适用于数值类型</p></li></ol><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var arrayList = arayOf(1,2,3,4,5)when(1){    in arrayList.toIntArray() -> println("1 存在于arrayList数组中")    in 0 .. 10 -> println("1 属于0~10中")    !in 5 ..10 -> println("1 不属于5~10中")else -> println("都错了！")}</code></pre><h3 id="检查值是否为指定类型的值">检查值是否为指定类型的值</h3><ol><li><p>操作符</p><ul><li>是<code>is</code></li><li>不是<code>!is</code></li></ul></li><li><p>注意：<code>kotlin</code>的智能转换可以访问类型的方法和属性</p></li></ol><p>例如：</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">when("abc"){    is String -> println("是字符串")    else -> println("不是字符串")}//智能转换var a:Int = 2when(a){    !is Int -> println("$a 不是一个整型的数")    else -> {        a = a.shl(2)        println("a => $a")    }}</code></pre><h3 id="不使用表达式的when语句">不使用表达式的when语句</h3><p>表示为最简单的布尔表达式</p><pre class=" language-language-kotlin"><code class="language-language-kotlin">var array = arrayOfNulls<String>(3)when{    true -> {        for (i in array){            print(" $i \t")        }        println()    }    else -> {            }}</code></pre><h2 id="其它语句">其它语句</h2><ul><li><p>while语句</p></li><li><p>do while语句</p></li><li><p>跳转语句：return，break，continue</p></li></ul><p>与C类语言一致，不做赘述。</p><h1>操作符</h1><h2 id="一元操作符">一元操作符</h2><h3 id="简单一元">简单一元</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">重载</th></tr></thead><tbody><tr><td style="text-align:center">+a</td><td style="text-align:center">a.unaryPlus()</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">a.unaryMinus()</td></tr><tr><td style="text-align:center">!a</td><td style="text-align:center">a.not()</td></tr></tbody></table><h3 id="复杂一元">复杂一元</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">重载</th><th style="text-align:center">表示</th></tr></thead><tbody><tr><td style="text-align:center">a++</td><td style="text-align:center">a.inc()</td><td style="text-align:center">a = a.also{ a.inc() }</td></tr><tr><td style="text-align:center">a–</td><td style="text-align:center">a.dec()</td><td style="text-align:center">a = a.also{ a.dec() }</td></tr><tr><td style="text-align:center">++a</td><td style="text-align:center">a.inc()</td><td style="text-align:center">a = a.inc().also{ a = it }</td></tr><tr><td style="text-align:center">–a</td><td style="text-align:center">a.dec()</td><td style="text-align:center">a = a.dec().also{ a = it }</td></tr></tbody></table><h2 id="二元操作符">二元操作符</h2><h3 id="简单二元">简单二元</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">重载</th></tr></thead><tbody><tr><td style="text-align:center">a + b</td><td style="text-align:center">a.plus(b)</td></tr><tr><td style="text-align:center">a - b</td><td style="text-align:center">a.minus(b)</td></tr><tr><td style="text-align:center">a * b</td><td style="text-align:center">a.tiems(b)</td></tr><tr><td style="text-align:center">a / b</td><td style="text-align:center">a.div(b)</td></tr><tr><td style="text-align:center">a % b</td><td style="text-align:center">a.rem(b)</td></tr><tr><td style="text-align:center">a … b</td><td style="text-align:center">a.rangTo(b)</td></tr></tbody></table><h3 id="复杂二元">复杂二元</h3><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">表示</th><th style="text-align:center">重载</th></tr></thead><tbody><tr><td style="text-align:center">a += b</td><td style="text-align:center">a = a + b</td><td style="text-align:center">a = a.plus(b)</td></tr><tr><td style="text-align:center">a -= b</td><td style="text-align:center">a = a - b</td><td style="text-align:center">a = a.minus(b)</td></tr><tr><td style="text-align:center">a *= b</td><td style="text-align:center">a = a * b</td><td style="text-align:center">a = a.tiems(b)</td></tr><tr><td style="text-align:center">a /= b</td><td style="text-align:center">a = a / b</td><td style="text-align:center">a = a.div(b)</td></tr><tr><td style="text-align:center">a %= b</td><td style="text-align:center">a = a % b</td><td style="text-align:center">a = a.rem(b)</td></tr></tbody></table><h2 id="区间操作">区间操作</h2><p>区间操作符：<code>..</code>，注意两个操作数都是整型</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">表示</th><th style="text-align:center">重载</th></tr></thead><tbody><tr><td style="text-align:center">a … b</td><td style="text-align:center">a 到 b 中间的值</td><td style="text-align:center">a.rangeTo(b)</td></tr></tbody></table><h1>进阶操作</h1><h2 id="可空类型，空安全">可空类型，空安全</h2><h3 id="定义一个可空类型的变量">定义一个可空类型的变量</h3><blockquote><p><strong>修饰符 变量名 : 类型? = 值</strong></p></blockquote><h3 id="判断可空类型的两种方式">判断可空类型的两种方式</h3><ul><li><p>if…else… 判断</p></li><li><p>使用符号<code>?.</code>判断</p><p>该符号的用法为：<code>可空类型变量?.属性/方法</code>。如果可空类型变量为null是，返回null；</p><p>这种方法大量用于<strong>链式操作</strong>的用法中，能有效避免<code>空引用异常</code>，因为只要链式中有一个<code>null</code>，则整个表达式都为<code>null</code>。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习使用方法及错误记录</title>
      <link href="/git.html"/>
      <url>/git.html</url>
      
        <content type="html"><![CDATA[<h2 id="git使用">git使用</h2><ul><li><p>初始化仓库</p><pre class=" language-language-shell"><code class="language-language-shell">git init</code></pre></li><li><p>添加文件/文件夹到本地仓库</p><pre class=" language-language-shell"><code class="language-language-shell">git add file.txtgit add Directorygit add .//添加当前目录所有项</code></pre></li><li><p>提交更改到本地仓库</p><pre class=" language-language-shell"><code class="language-language-shell">git commit -m "initial commit"</code></pre></li><li><p>关联远程仓库</p><pre class=" language-language-shell"><code class="language-language-shell">git remote add origin git@github.com:Mahoo12138/android_learn_demo.git</code></pre></li><li><p>推送到远程仓库</p><pre><code>git push origin master</code></pre></li><li><p>本地仓库删除文件</p><pre class=" language-language-shell"><code class="language-language-shell">git rm -r Directory</code></pre></li><li><p>回退本地版本</p><ul><li><p>先找到回退版本的<code>commit id</code>：</p><pre class=" language-language-shell"><code class="language-language-shell">git reflog</code></pre></li><li><p>然后回退版本</p><pre class=" language-language-shell"><code class="language-language-shell">git reset --hard commit id</code></pre></li></ul></li><li><p>远程分支回退</p><ul><li><p>先回退本地分支</p></li><li><p>强制推送到远程分支</p><pre class=" language-language-shell"><code class="language-language-shell">git push -f origin master</code></pre><p><code>origin</code>是一个名字，指的是你的远程代码库的标签，而<code>master</code>就是这个远程代码库repository的主分支</p></li></ul></li></ul><h2 id="错误记录">错误记录</h2><ul><li><p>git pull 失败 ,提示：<code>fatal: refusing to merge unrelated histories</code></p><p>**原因：**无关的仓库无法合并</p><p><strong>方法：</strong></p><ul><li><p>使用强制命令：</p><pre class=" language-language-sh"><code class="language-language-sh">git pull origin master --allow-unrelated-histories</code></pre></li><li><p>先将远程仓库拉取到本地仓库，再推送</p></li></ul></li><li><p>git push 失败，提示：<code>Updates were rejected because the tip of your current branch is behind</code></p><p>**原因：**本地仓库版本低于远程仓库版本，或做了一些自定义修改</p><p><strong>方法：</strong></p><ul><li><p>强制推送</p><pre class=" language-language-shell"><code class="language-language-shell"> git push -u origin master -f</code></pre></li></ul></li></ul><h2 id="其他">其他</h2><ul><li><p>Win10下 git bash 中文显示乱码：类似﷨﷨﷨﷨或▒▒▒▒</p><p><strong>解决方法</strong>：</p><ul><li>在窗口内右击，选择<code>Options...</code></li><li>在<code>Text</code>内，选择Locale为<em>zh_CN</em>，Character set 为<em>GBK</em></li><li>Save</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么！我怎么突然就不是处男了???</title>
      <link href="/life-greenhand.html"/>
      <url>/life-greenhand.html</url>
      
        <content type="html"><![CDATA[<p>最近，一位要好的朋友没事做要我发给TA我的手臂照片，我当时也没想什么，就撸起袖子拍了，结果TA给我发了这个：</p><blockquote><p>在人的手臂关节内侧，往手掌方向大约一寸左右的地方，有一道类似于刀痕或手指甲划痕的线，一般都很明显，这就是所谓的处男线了.</p></blockquote><p>我赶紧细细观摩我的手臂，呕吼！还真没有，不可能吧，以我多年混迹网络的经验，这又是哪里流出来的谣言，赶紧谷歌一波以示清白！<br>在网络上看到了一些网友的评论：<a id="more"></a></p><blockquote><p>1.<strong>网友：紫菜蛋花汤 23岁 大学在读</strong></p><blockquote><p>我同学就是处男，他真的有处男线。我今年上大三，我们寝室一共4个人，其中一个学霸是处男，其他3个（算上我）都不是了，那天看到网上的介绍我们赶紧亮出胳膊来对比一下，果然只有学霸一个人胳膊上有处男线！我觉得这不仅仅是巧合吧！网上说：有医学书证明，在男孩子的手臂关节内侧，往手掌方向大约一寸左右的地方，有一道类似于刀痕或手指甲划痕的线，一般都很明显，这就是所谓的处男线了。如果有过性生活，这条线就会消失。可见，这不是子虚乌有，看来处男处女都是可以通过外貌来鉴定的。</p></blockquote></blockquote><blockquote><p><strong>2.网友：博士不是后 34岁 商务总监</strong></p><blockquote><p>我孩子都两岁半了，怎么还有处男线关于处男线的说法，我也早就听说过，但却不敢苟同。我的女儿都两岁半了，但我的处男线依然存在！我觉得这就是人们拿来开玩笑的噱头，要是我这样的人都是处男，那世界岂不是要乱套了。</p></blockquote></blockquote><p>随后我有观察我几个舍友：</p><table><thead><tr><th style="text-align:center">室友</th><th style="text-align:center">是否处男</th><th style="text-align:center">有无处男线</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">是</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">是</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">否</td><td style="text-align:center">无</td></tr></tbody></table><p>如此一番看来，所谓的**“处男线”**根本就不存在。</p><p>怀着对这个问题的好奇心，我又继续看了专家对于这个问题的看法：</p><h5 id="福建师范大学生命科学学院的副院长-陈寅山">福建师范大学生命科学学院的副院长 陈寅山</h5><blockquote><p>所谓的“处男线”根本就不存在，一般瘦的人和年纪大的人都比较容易显现。</p></blockquote><p>“这也太胡扯了，完全没有科学依据。”福建师范大学生命科学学院的副院长陈寅山介绍，所谓的“处男线”根本就不存在，要辨别男性是不是处男，应该通过身体内部的变化来判断，而不是皮肤表面的现象。对于男性手肘上的这条线，陈院长表示，这可能是人体的静脉，“男女都会有，一般瘦的人和年纪大的人都比较容易显现。”。</p><p>此外，我也查询了专业的处男鉴定方法，如下：</p><h4 id="Communities-of-the-Coronal-Sulcus-and-Distal-Urethra-of-Adolescent-Males">Communities of the Coronal Sulcus and Distal Urethra of Adolescent Males</h4><p>** <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0036298" target="_blank" rel="noopener">原文链接</a>**</p><p>这篇论文发布于2012年5月，是美国印第安纳大学布鲁明顿分校生物系一个专攻“微生物与环境”问题的团队，在《科学公共图书馆·综合》杂志上发表的，主要研究的就是“鉴定处男”的方法<br>由于博主我英语还没到这个水平，就不能详细地说其中的实验研究过程了，大致就是利用一种叫16S rRNA的基因检测技术，检验尿道和阴道里的细菌分类群，说得土一点，就是有性生活的人，菌落类群会有很大的不同，也就是会改变外生殖器内的菌群，由此达到检验是否是“处男”的目的。研究报告最后也说到由于男女菌落分布的一些相似性和样本量小的原因，这样来检测估计也不太靠谱！</p><p>最后，我再放几个网上流传的关于鉴别“处男”的谣言，相信大家一看就知道这是可笑的说法！</p><blockquote><p><strong>1.</strong> 处男上厕所小便与非处男是完全不同的。急急忙忙地冲进厕所，还没有走拢小便池就憋不住了，掏出家伙就洒，小便如消防战士的高压水龙头，喷在对面的墙壁上，反弹回来还把自己的头发淋成落汤鸡的，是处男。反之，慢吞吞地蹩进厕所，左顾右盼地走拢小便池，伸一只手在裤裆里掏啊掏啊，如同粗心的主妇在大提包里找钥匙，找了半分钟才找到自己的工具，然后就站在那里一动不动，仿佛在思考一道世界难题，待一起进厕所去大便的人都已经结束时，他才自己给自己吹着口哨小便出来。脸都要贴到墙上去了，腰都快弯成弓了，可收工的时候，发现还是不争气地把自己的棉鞋给打湿了，这绝对是非处男<br>**2. **处男一般不会当着女孩子的面赤裸上身，更不会穿条大裆短裤在街上闲逛，只喜欢穿着紧绷绷的上衣显示胸大肌。非处男就不同了，天气稍微一热，就迫不及待地把自己的上衣扒掉，生怕别人看不见他故掉肚的奶油似的，看见有女孩子从面前经过，还要把奶油肚皮一晃一晃的作肉海翻腾状。<br>**3. **进大澡堂洗澡时，处男会在腰上系一条毛巾遮住羞处，洗澡时一般都很害羞地把背对着大家，却又很注意地看其他男人的羞处，然后小心地与自己的对比。非处男就大咧咧地裸着进来，下面的东东左摇右晃，如同挂在腰上的水烟袋却浑然不知。说他不知，他却在跟别人说话的时候，有意无意地用指头去拨弄几下，仿佛是在逗一只鹦鹉。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 处男线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的cin,getchar,get,getline详解</title>
      <link href="/c-c-0.html"/>
      <url>/c-c-0.html</url>
      
        <content type="html"><![CDATA[<h1>cin</h1><p>获取输入的一个字符或数字：</p><pre class=" language-language-c++"><code class="language-language-c++">int a;cin >> a;</code></pre><p>cin &gt;&gt; 会自动隐性字符，如空格，制表符（Tab），回车等，若不想过滤掉这些字符，可以用noskipws流进行控制，后文会对noskipws这些操作符做一个总结，先看例子：</p><pre class=" language-language-c++"><code class="language-language-c++">char test[5];for (int i = 0;i < 5;i++){    cin >> noskipws >> test[i];}for (int i = 0;i < 5;i++){    cout << test[i];}</code></pre><p>输出结果如下：</p><pre class=" language-language-c++"><code class="language-language-c++">ma ooma oo</code></pre><p>还有一个要注意的是，使用cin输入时遇到空白字符后后面的字符会被过滤掉，即会停留在缓冲区，当下一个cin输入时会直接从缓冲区读取：</p><pre class=" language-language-c++"><code class="language-language-c++">char test_1[10];char test_2[10];cin >> test_1;cin >> test_2;cout << test_1 << endl;cout << test_2 << endl;</code></pre><p>执行结果如下：</p><pre class=" language-language-c++"><code class="language-language-c++">Hello World     //输入字符Hello           //test_1，遇到空格停止输入World           //test_2，从输入流缓冲区读取被过滤掉的字符</code></pre><h1>cin.get()</h1><h2 id="含一个参数">含一个参数</h2><p>cin.get(数组名)，一次读取一个字符：</p><pre class=" language-language-c++"><code class="language-language-c++">char test[5];for (int i = 0;i < 5;i++){    cin.get(test[i]);}</code></pre><h2 id="含两个参数">含两个参数</h2><p>cin.get(数组名,接收的字符数量)，可以接收空格，遇到回车停止。先看例子：</p><pre class=" language-language-c++"><code class="language-language-c++">char test_1[10];cin.get(test_1,10);cout << test_1;</code></pre><p>执行如下：</p><pre class=" language-language-c++"><code class="language-language-c++">1234567890          //输入10个数字123456789           //输出了前9个</code></pre><p>因为数组最后一个字符是’\0’,所以字符长度为10的数组只能接收9个字符。</p><h1>cin.getline()</h1><p>函数重载显示：</p><pre class=" language-language-c++"><code class="language-language-c++">istream& getline (char* s, streamsize n );istream& getline (char* s, streamsize n, char delim );</code></pre><p>getline内有三个参数，一个字符数组，一个读取的数量，以及定界字符（默认’\n’）,通过流对象调用使用，读取的最后一个字符为’\0’，例如：</p><pre class=" language-language-c++"><code class="language-language-c++">char test[5];cin.getline(test,5);cout << test;</code></pre><p>输入输出结果：</p><pre class=" language-language-c++"><code class="language-language-c++">ma hooma h</code></pre><h1>getline (string)</h1><p>重载形式：</p><pre class=" language-language-c++"><code class="language-language-c++">istream& getline (istream&  is, string& str, char delim);istream& getline (istream&& is, string& str, char delim);istream& getline (istream&  is, string& str);istream& getline (istream&& is, string& str);</code></pre><p>首先看到string就知道这应该要包含#include&lt;<strong>string</strong>&gt;头文件，getline内有三个参数，一个流对象，字符串和定界字符，例如：</p><pre class=" language-language-c++"><code class="language-language-c++">char ch = 'o';    //定界字符'o'string str;getline(cin,str,ch);cout << str;</code></pre><pre class=" language-language-c++"><code class="language-language-c++">mahoo    //控制台输入mah      //输出，遇到定界字符'o'停止提取字符到str</code></pre><p>当然，也可以不用定界字符参数，默认为’\n’，getline可以接受空格，不能接受回车，据我测试，getline执行后会把缓冲区中的回车读走，但没有存入到指定的字符串中，贴代码：</p><p><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/C++/test.png" alt=""><br>当输入"mahoo"(getline)和"a"(getchar)后，"b"读到了<code>c = getchar()</code>缓冲区的<code>'\n'</code>，而<code>c = getchar()</code>却没读到<code>getline</code>的回车。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的文件输入和输出</title>
      <link href="/c-c-1.html"/>
      <url>/c-c-1.html</url>
      
        <content type="html"><![CDATA[<p>C++ I/O类软件包处理文件输入和输出的方式与处理标准输入和输出的方式非常相似。<br><img src="https://cdn.jsdelivr.net/gh/mahoo12138/js-css-cdn@1.0/hexo_images/hexo_images/C++/file.png" alt=""></p><h2 id="简单的文件I-O">简单的文件I/O</h2><p>要让程序写入文件，必须这样做:</p><ul><li>创建一个ofstream对象来管理输出流；</li><li>将该对象与特定的文件关联起来；</li><li>以使用cout的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。</li></ul><h3 id="写入文件">写入文件</h3><p>前提是要包含头文件<strong>fstream</strong>，对于大部分操作（不是全部），包含该头文件，等于自动包含了iostream文件，因为该头文件中的类都是派生自头文件iostream中的类。因此不必再包含iosteam文件。<br>先声明一个ofsteam对象：</p><pre class=" language-language-C++"><code class="language-language-C++"> ofstream fout;        </code></pre><p>之后，必须将这个对象与特定的文件关联起来，可以使用成员函数open()来实现，例如要打开<code>mahoo.txt</code>进行操作：</p><pre class=" language-language-c++"><code class="language-language-c++">fout.open("mahoo.txt");</code></pre><p>也可以使用一个构造函数，将两行代码（创建对象和关联文件）合并：</p><pre class=" language-language-c++"><code class="language-language-c++">ofstream fout (mahoo.txt);</code></pre><p>然后以<strong>cout</strong>的方式操作fout对象。例如要把文本"I am Mahoo"放入到文件中，可以这样做：</p><pre class=" language-language-c++"><code class="language-language-c++">fout << "I am Mahoo";</code></pre><p>由于ostream是ofstream类的基类，因此可以使用所有的ostream方法，包括各种运算符定义，格式化方法和控制符。ofstream类使用被缓存的输出，因此程序再创建像fout这样的ofstream对象时，将为输出缓冲区分配空间。如果创建了两个ofstream对象，程序将创建两个缓冲区，各一个。像fout这样的ofstream对象从程序那里逐字节地收集输出，当缓冲区填满后，它便将缓冲区内容一同传输给目标文件。<br>注意，以这样的方式打开文件操作时，如果没有该文件，会创建一个新的文件；如果有将清空文件。</p><h3 id="读取文件">读取文件</h3><p>读取文件操作与写入文件类似：</p><ul><li>创建一个ifstream对象管理输入流;</li><li>将该对象与特定的文件关联起来；</li><li>以cin的方式使用该对象。</li></ul><p>当然，包含头文件fstream必不可少。</p><pre class=" language-language-c++"><code class="language-language-c++">ifstream fin;            fin.open("Mahoo.txt");ifstream fin("Mahoo.txt");</code></pre><p>现在，可以像使用cin那样使用fin：</p><pre class=" language-language-c++"><code class="language-language-c++">char ch;               fin >> ch;              //从mahoo.txt中读取一个字符char test[100];fin >> test;            //一直读取，知道读取到enter，tab，space等fin.getline(test,100);  //读取一行存入test[100]string line;getline(fin,line);      //读取到string对象line中</code></pre><p>在上述代码<code>getline(fin,line)</code>对于文件内容只读取一行，补充一下string对象的长度大小，其限制基于当前编译器，可以使用：</p><pre class=" language-language-c++"><code class="language-language-c++">cout << line.max_size();     //line为创建的string对象</code></pre><p>查看当前编译器理论上支持的最大长度。</p><h3 id="关闭文件">关闭文件</h3><p>当输入和输出流对象过期（如程序终止时），文件的连接将自动关闭。作为一名合格的程序员，绝不会这么做，可以使用close()方法显式地关闭到文件的连接：</p><pre class=" language-language-C++"><code class="language-language-C++">fout.close();fin.close();</code></pre><p>OK，今天的学习就到这里了，累了，睡觉！</p><hr><p><em>2019年5月14日更新</em></p><h3 id="打开文件的模式">打开文件的模式</h3><p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><pre class=" language-language-c++"><code class="language-language-c++">void open(const char *filename, ios::openmode mode);</code></pre><p>open() 成员函数其实有两个参数，第一个参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p><table><thead><tr><th style="text-align:center">模式标志</th><th style="text-align:center">简单描述</th></tr></thead><tbody><tr><td style="text-align:center">ios::in</td><td style="text-align:center">打开文件用于读取</td></tr><tr><td style="text-align:center">ios::out</td><td style="text-align:center">打开文件用于写入</td></tr><tr><td style="text-align:center">ios::app</td><td style="text-align:center">追加模式：即把所有的写入放到末尾</td></tr><tr><td style="text-align:center">ios::ate</td><td style="text-align:center">文件打开后，定位到末尾</td></tr><tr><td style="text-align:center">ios::trunc</td><td style="text-align:center">预打开文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0</td></tr><tr><td style="text-align:center">ios::binary</td><td style="text-align:center">以二进制方式打开</td></tr></tbody></table><p>而且这些当时可以任意组合，通过 ** “|” **（运算符“或”）进行连接即可例如：</p><pre class=" language-language-c++"><code class="language-language-c++">ofstream fout;fout.open("Mahoo.txt", ios::in|ios::out|ios::binary);    //根据实际需要进行组合</code></pre><h3 id="检查文件是否被成功打开">检查文件是否被成功打开</h3><p>在操作文件时，我们都应该检查文件是否被成功打开，否则进行读取的时候就会报错。具体方法可以使用<strong>is_open()</strong>，例如：</p><pre class=" language-language-c++"><code class="language-language-c++">fin.open("Mahoo.txt");if (!fin.is_open()){       exit(EXIT_FAILURE);}</code></pre><p>如果文件成功被打开，方法is_open()将返回true；exit()函数作用是关闭所有打开的文件并终止程序，并将参数value返回给主调进程。</p><pre class=" language-language-c++"><code class="language-language-c++">void exit(int value);    //一般0表示程序寿终正寝，1表示死于非命。</code></pre><p><strong>EXIT_FAILURE</strong>是定义在cstdlib.h中的一个常量，通常EXIT_SUCCESS = 0，EXIT_FAILURE = 1。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统内的Java环境变量配置</title>
      <link href="/java-jdk.html"/>
      <url>/java-jdk.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装Java的JDK">安装Java的JDK</h2><p>首先去<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官网链接</a>把JDK下载安装好，我安装的是最新版本的<em>jdk-8u211-windows-x64</em>，由于我总是忘记环境变量的配置，所以决定写篇博文记录，OK，开始配置！<a id="more"></a></p><h2 id="环境变量配置">环境变量配置</h2><p>在桌面右键单击<strong>此电脑</strong>进入<strong>属性</strong>，<br><img src="http://yun.airlife.club/view.php/4544a12f50a60e864cdd060b6128a9d7.png" alt=""></p><p>点击左栏的<strong>高级系统设置</strong>再然后是<strong>环境变量</strong>，<br><img src="http://yun.airlife.club/view.php/e379426a4bc0447112736d7cf9429822.png" alt=""><br>接下来就是核心要点了，咳咳，圈重点了哦</p><ol><li>点击【系统变量】下面的【新建】选项，在【变量名】处填上【Java_Home】，【变量值】就是你刚才JDK安装的路径，我的是*”C:\Program Files\Java\jdk1.8.0_211“*，点击【确定】；<br><img src="http://yun.airlife.club/view.php/7ba200957f85d66fcf828a3c203cc8bb.png" alt=""></li><li>在【系统变量】中找到【Path】，选中并点击【编辑】，再点击右侧的【编辑文本】，将引号里面的全部复制**“%Java_Home%\bin;%Java_Home%\jre\bin;”**，到“变量值”栏的最前面，【确定】；<br><img src="http://yun.airlife.club/view.php/5731314d7a32fa1be535c13d27844cd1.png" alt=""></li><li>在【系统变量】中，【新建】一个【变量名】为“CLASSPATH”，【变量值】为*“.;%Java_Home%\bin;%Java_Home%\lib\dt.jar;%Java_Home%\lib\tools.jar”*<br><img src="http://yun.airlife.club/view.php/b72aa91ef838c21039e2197337e8f6ff.png" alt=""></li><li>一路【确定】回退到桌面，打开Cmd控制台，方法挺多，一般就是”Win+R",输入“cmd”，回车，开始检测Java环境是否配置成功：</li></ol><ul><li>输入"Java"，回车；</li><li>输入"Javac"，回车；</li><li>输入"Java -version"，回车；<br><img src="http://yun.airlife.club/view.php/afc11ff2097f9f5b1a38b8b27a44938f.png" alt=""><br><img src="http://yun.airlife.club/view.php/a8a27058556630beefc44e9c2de59b68.png" alt=""><br><img src="http://yun.airlife.club/view.php/3ba7991598360c47b82617a07daac8c6.png" alt=""></li></ul><ol start="5"><li>三次都出现如图类似的信息，说明<strong>配置成功</strong>！</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
